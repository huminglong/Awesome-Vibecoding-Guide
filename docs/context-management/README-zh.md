# 上下文管理 🧠

**TL;DR：** 对话是短暂的，文件是永久的。尽早且经常地将知识外部化到.md文件。保持对话小而专注。使用MCP服务器进行外部数据检索。

---

## 目录

1. [基础](#基础)
2. [核心原则](#核心原则)
3. [代理特定策略](#代理特定策略)
4. [基于.md的工作流程模式](#基于-md-的工作流程模式)
5. [按任务类型的上下文管理](#按任务类型的上下文管理)
6. [技术和模式](#技术和模式)
7. [文件组织](#上下文管理的文件组织)
8. [高级策略](#高级策略)
9. [监控和故障排除](#监控和故障排除)
10. [MCP服务器](#用于上下文管理的-mcp-服务器)
11. [最佳实践检查清单](#最佳实践检查清单)
12. [真实场景](#真实场景)

---

## 基础

### 上下文作为资源管理

将上下文视为RAM或预算：
- **有限容量** - 每个模型都有上下文窗口限制
- **性能影响** - 更多上下文 = 更慢的响应、更高的成本
- **满载时降级** - AI质量在限制附近下降
- **必须有意管理** - 不是自动的

**黄金法则：** 上下文是您在Vibecoding中最有价值的资源。像管理性能关键系统中的内存一样管理它。

### Markdown记忆模式 ⭐

**核心洞察：** 生活在.md文件中的东西不消耗您的对话上下文。

传统方法：
```
对话：计划 → 讨论 → 实施 → 解释 → 调试 → 重复
使用的上下文：200k令牌（达到限制）
```

基于Markdown的方法：
```
编写plan.md → 对话："实施plan.md" → 更新plan.md
使用的上下文：20k令牌（节省90%）
```

**为什么.md文件更优越：**
- ✅ 跨会话持久
- ✅ 版本控制（git）
- ✅ 人类可编辑
- ✅ 代理可以在不重新阅读对话的情况下引用
- ✅ 多个代理可以共享相同的知识
- ✅ 初始读取后零上下文成本

**现实中的示例：**
- **openspec工具**：将功能提案写入.md文件
- **droid CLI**：计划模式 → 创建.md → 执行模式读取它
- **Claude Code**：计划模式可以在执行前输出到.md
- **所有代理**：可以读/写.md以进行持久记忆

### 上下文层次结构

并非所有上下文都是平等的。按访问模式组织：

| 级别       | 什么          | 在哪里           | 成本           |
| ---------- | ------------- | ---------------- | -------------- |
| **活动**   | 当前工作      | 对话             | 高（在RAM中）  |
| **可检索** | 项目知识      | docs/中的.md文件 | 低（按需读取） |
| **外部**   | 框架文档、API | MCP服务器        | 零（按需拉取） |

**决策树：**
```
这是否是当前任务现在需要的？
├─ 是 → 保留在对话中（活动上下文）
└─ 否 → 这是项目特定知识吗？
    ├─ 是 → 写入.md文件（可检索上下文）
    └─ 否 → 使用MCP服务器（外部上下文）
```

### 心理模型

**代理如何处理上下文：**

1. **近期偏差** - 最近的消息有更多权重
2. **注意力限制** - 不能平等地关注所有上下文
3. **模式匹配** - 寻找相关块
4. **完成压力** - 接近令牌限制 = 匆忙的响应

**这对您意味着什么：**
- 将关键信息放在上下文的末尾
- 删除不相关的文件/消息
- 清晰地构建信息
- 不要达到上下文窗口的100%

---