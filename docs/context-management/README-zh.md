# 上下文管理 🧠

**TL;DR：** 对话是短暂的，文件是永久的。尽早且经常地将知识外部化到.md文件。保持对话小而专注。使用MCP服务器进行外部数据检索。

---

## 目录

1. [基础](#基础)
2. [核心原则](#核心原则)
3. [代理特定策略](#代理特定策略)
4. [基于.md的工作流程模式](#基于-md-的工作流程模式)
5. [按任务类型的上下文管理](#按任务类型的上下文管理)
6. [技术和模式](#技术和模式)
7. [文件组织](#上下文管理的文件组织)
8. [高级策略](#高级策略)
9. [监控和故障排除](#监控和故障排除)
10. [MCP服务器](#用于上下文管理的-mcp-服务器)
11. [最佳实践检查清单](#最佳实践检查清单)
12. [真实场景](#真实场景)

---

## 基础

### 上下文作为资源管理

将上下文视为RAM或预算：
- **有限容量** - 每个模型都有上下文窗口限制
- **性能影响** - 更多上下文 = 更慢的响应、更高的成本
- **满载时降级** - AI质量在限制附近下降
- **必须有意管理** - 不是自动的

**黄金法则：** 上下文是您在Vibecoding中最有价值的资源。像管理性能关键系统中的内存一样管理它。

### Markdown记忆模式 ⭐

**核心洞察：** 生活在.md文件中的东西不消耗您的对话上下文。

传统方法：
```
对话：计划 → 讨论 → 实施 → 解释 → 调试 → 重复
使用的上下文：200k令牌（达到限制）
```

基于Markdown的方法：
```
编写plan.md → 对话："实施plan.md" → 更新plan.md
使用的上下文：20k令牌（节省90%）
```

**为什么.md文件更优越：**
- ✅ 跨会话持久
- ✅ 版本控制（git）
- ✅ 人类可编辑
- ✅ 代理可以在不重新阅读对话的情况下引用
- ✅ 多个代理可以共享相同的知识
- ✅ 初始读取后零上下文成本

**现实中的示例：**
- **openspec工具**：将功能提案写入.md文件
- **droid CLI**：计划模式 → 创建.md → 执行模式读取它
- **Claude Code**：计划模式可以在执行前输出到.md
- **所有代理**：可以读/写.md以进行持久记忆

### 上下文层次结构

并非所有上下文都是平等的。按访问模式组织：

| 级别       | 什么          | 在哪里           | 成本           |
| ---------- | ------------- | ---------------- | -------------- |
| **活动**   | 当前工作      | 对话             | 高（在RAM中）  |
| **可检索** | 项目知识      | docs/中的.md文件 | 低（按需读取） |
| **外部**   | 框架文档、API | MCP服务器        | 零（按需拉取） |

**决策树：**
```
这是否是当前任务现在需要的？
├─ 是 → 保留在对话中（活动上下文）
└─ 否 → 这是项目特定知识吗？
    ├─ 是 → 写入.md文件（可检索上下文）
    └─ 否 → 使用MCP服务器（外部上下文）
```

### 心理模型

**代理如何处理上下文：**

1. **近期偏差** - 最近的消息有更多权重
2. **注意力限制** - 不能平等地关注所有上下文
3. **模式匹配** - 寻找相关块
4. **完成压力** - 接近令牌限制 = 匆忙的响应

**这对您意味着什么：**
- 将关键信息放在上下文的末尾
- 删除不相关的文件/消息
- 清晰地构建信息
- 不要达到上下文窗口的100%

---

## 核心原则

### 1. 外部化，不要记忆

**不良模式：**
```
你："记住我们决定使用PostgreSQL和UUID主键"
代理："明白了，我会记住"
[200条消息后]
代理：*建议使用整数ID*
```

**良好模式：**
```
你："将此记录到docs/decisions/database.md"
代理：*将决策写入文件*
[200条消息后]
你："检查docs/decisions/database.md"
代理：*读取文件，遵循决策*
```

### 2. 战略性 vs. 战术性上下文

**战略性**（属于.md文件）：
- 架构决策
- 项目约定
- 功能规范
- API设计
- 长期计划

**战术性**（属于对话）：
- 当前实现细节
- 立即调试步骤
- 快速澄清
- 活动文件编辑

### 3. 质量优于数量

**不要：**
- "以防万一"包含整个src/文件夹
- 实现功能时添加所有测试
- 保持旧对话线程活动

**要做：**
- 只包含与当前任务直接相关的文件
- 只在编写测试时添加测试文件
- 压缩或外部化已完成的工作

### 4. 上下文债务

像技术债务一样，上下文债务会累积：

**上下文债务的迹象：**
- 代理忘记最近的决策
- 重复的问题
- 矛盾的建议
- 响应时间变慢

**如何偿还：**
- 外部化到.md文件
- 从摘要开始新会话
- 从上下文中移除已完成的工作
- 清理冗余消息

### 5. 60-85%规则

**上下文窗口策略：**

- **0-60%**：最佳区域 - 代理"聪明"且彻底
- **60-85%**：工作区域 - 可用但密切监控
- **85-95%**：危险区域 - 质量下降，开始压缩
- **95-100%**：红色区域 - 代理匆忙完成，犯错误

**专业提示：** 如果您有1M上下文窗口（Claude Sonnet 4.5，Qwen3 Coder），您可以填充更多但计划在约200k时压缩。这可以防止"上下文结束"压力。

**实践：**
```
定期检查您的上下文使用情况：
- Claude Code：在UI中监控令牌计数
- Windsurf：检查级联上下文指示器
- Zed：自动压缩触发器
- API使用：通过提供商仪表板跟踪
```

---

## 代理特定策略

### Claude Code

**最佳实践：**

1. **主动使用TodoWrite**
   - 将工作分解为可跟踪的任务
   - 帮助代理保持专注
   - 您可以实时查看进度

2. **利用任务代理**
   - 使用Explore代理进行代码库理解
   - 将研究卸载到后台代理
   - 尽可能并行探索

3. **计划模式工作流程**
   ```
   1. 进入计划模式
   2. 讨论方法
   3. 将计划写入docs/plans/feature-name.md
   4. 退出计划模式
   5. 执行："实施docs/plans/feature-name.md"
   ```

4. **并行工具调用**
   - Claude Code可以同时读取多个文件
   - 在一条消息中请求多个独立文件读取
   - 节省往返时间和上下文

5. **引用格式**
   - 使用`file_path:line_number`进行精确引用
   - 代理可以直接跳转到相关代码
   - 示例："检查auth.ts:145的问题"

### Windsurf

**使用Cascade进行上下文管理：**

1. **重复模式的流程**
   - 记录常见工作流程
   - Cascade引用流程而不是重新解释
   - 在重复任务上节省上下文

2. **文档模式**
   - 在docs/中保留架构文档
   - Cascade可以按需拉取相关文档
   - 随项目发展更新文档

### Zed

**自动压缩功能：**

1. **自动摘要**
   - 当上下文填满时 → Zed创建摘要
   - 对话自动压缩
   - 保留基本上下文
   - 无需手动重置即可继续

2. **工作流程**
   - 定义可重用的工作流程
   - 引用而不是重新解释
   - 减少对话开销

### Droid CLI

**计划/执行分离模式：**

```bash
# 计划模式 - 创建策略
droid plan "实施用户身份验证"
# 输出：.tasks/auth-feature.md

# 执行模式 - 从计划执行
droid act .tasks/auth-feature.md
# 代理读取计划，逐步实施
```

**为什么这有效：**
- 计划使用上下文创建全面计划
- 计划被写入.md文件
- 执行模式读取计划（小上下文成本）
- 可以恢复/重新开始而无需重新计划
- 可以从同一计划多次尝试执行

### 通用IDE代理

**通用模式：**

1. **从.cursorrules或.clauderules开始**
   - 项目范围指令
   - 自动加载
   - 不要在每次对话中重复自己

2. **保持活动文件数量少**
   - 大多数代理跟踪"打开"或"包含"的文件
   - 完成时关闭文件
   - 需要时重新打开（读取便宜）

3. **使用注释进行持久化**
   - 在代码中添加TODO以供将来工作
   - 代理可以grep查找TODO
   - 比在对话中记住更好

---

## 基于.md的工作流程模式

### 计划阶段

**步骤1：创建全面计划**

使用规划工具或手动编写：
```
选项：
- openspec工具 → 生成proposal.md
- droid CLI → 计划模式创建.tasks/*.md
- Claude Code → 计划模式，然后保存到.md
- 手动 → 自己编写docs/plans/feature.md
```

**步骤2：构建您的计划**

模板结构：
```markdown
# 功能：[名称]

## 问题
我们在解决什么？

## 方法
我们将如何解决它？

## 任务
- [ ] 任务1
- [ ] 任务2
- [ ] 任务3

## 成功标准
我们如何知道它完成了？

## 技术决策
- 决策1：...
- 决策2：...
```

**步骤3：保存到适当位置**

```
docs/
├── plans/           # 功能计划（openspec输出）
├── proposals/       # 设计提案
├── decisions/       # ADR（架构决策记录）
└── tasks/           # 活动工作分解
```

### 执行阶段

**步骤1：引用计划**

而不是：
```
你："实施用户身份验证，使用JWT令牌，刷新令牌，基于角色的
访问控制，使用bcrypt进行密码哈希，电子邮件验证，以及..."
[使用500个令牌]
```

这样做：
```
你："实施docs/plans/auth.md"
[使用10个令牌，代理读取计划使用50个令牌]
总计：60个令牌 vs 500个令牌
```

**步骤2：代理读取并执行**

代理工作流程：
1. 读取plan.md（一次性成本）
2. 执行任务1
3. 如需要参考计划（便宜读取）
4. 执行任务2
5. 用进度更新plan.md
6. 继续...

**步骤3：随进行更新**

```markdown
## 任务
- [x] 任务1 ✅
- [x] 任务2 ✅
- [ ] 任务3 🔄 进行中
- [ ] 任务4

## 注意事项
- 任务2：必须使用bcrypt而不是argon2（依赖问题）
- 任务3：发现我们需要用户表的迁移
```

### 好处

**1. 会话持久性**
```
第1天：计划功能 → 实施50%
[关闭笔记本电脑]
第2天："继续docs/plans/feature.md" → 从您离开的地方继续
```

**2. 多个代理，相同计划**
```
代理1：实施后端（读取计划）
代理2：实施前端（读取相同计划）
两者对齐，无需同步开销
```

**3. 版本控制**
```bash
git log docs/plans/auth.md
# 查看计划的演变
git diff docs/plans/auth.md
# 审查方法的更改
```

**4. 人类监督**
```
代理："我已创建docs/plans/refactor.md供审查"
您：*阅读，编辑，改进*
代理："实施更新的docs/plans/refactor.md"
```

**5. 零上下文成本扩展**
```
小功能：计划 = .md中100个令牌，引用10次 = 总计100个令牌
大功能：计划 = .md中2000个令牌，引用10次 = 总计2000个令牌
无论您引用一次还是100次，成本相同！
```

### 支持此模式的工具

| 工具 | 如何使用.md |
|------|----------------|
| **openspec** | 以.md格式生成提案 |
| **droid CLI** | 计划模式 → .md → 执行模式 |
| **Claude Code** | 手动.md编写，计划模式输出 |
| **Windsurf** | Cascade引用文档 |
| **Zed** | 文件中的工作流程定义 |
| **所有代理** | 可以读/写.md文件 |

---

## 按任务类型的上下文管理

### 功能开发

**方法：写优先工作流程**

```
1. 将功能规范写入docs/plans/feature-name.md
2. 在.md中分解为子任务
3. 对话："实施docs/plans/feature-name.md"
4. 随进度更新.md
5. 如果是架构性的，在docs/decisions/中记录决策
```

**上下文使用：**
- 规范：~500个令牌（一次性读取）
- 实现对话：每个子任务~5k令牌
- 总计：大型功能~20k令牌

vs. 传统方法：~150k令牌

### 调试

**方法：狭窄和专注**

```
1. 最小上下文：错误消息 + 相关文件
2. 不要包含整个代码库
3. 仅在需要时增量添加文件
4. 如果不明显，在docs/fixes/中记录解决方案
```

**示例：**
```
坏：包含所有文件，完整日志，整个堆栈跟踪
好：错误消息 + auth.ts + 最小堆栈跟踪
     仅在需要时添加更多文件
```

### 重构

**方法：首先记录架构**

```
1. 编写docs/decisions/refactor-rationale.md
   - 当前状态
   - 问题
   - 提议的解决方案
   - 迁移计划
2. 对话："按照docs/decisions/...执行重构"
3. 用实际更改更新.md
```

**为什么这很重要：**
- 重构决策需要持久化
- 未来的您/代理需要理解为什么
- 容易暂停/恢复大型重构

### 代码审查

**方法：检查清单驱动**

```
1. 使用检查清单创建docs/reviews/pr-123.md
2. 代理根据检查清单审查代码
3. 发现结果写入.md
4. 对话保持专注于当前文件
```

**好处：**
- 审查标准一致
- 发现结果被记录
- 可以在多个会话中审查大型PR

### 文档

**方法：知识保存**

```
在构建时：
- docs/architecture/ ← 系统设计
- docs/guides/ ← 操作方法
- docs/decisions/ ← ADR
- docs/api/ ← API文档

代理引用这些而不是要求您解释
```

---

## 技术和模式

### 1. 选择性文件包含

**模块化结构：**

```
project/
├── src/
│   ├── components/   # 仅在使用UI时
│   ├── api/          # 仅在后端工作时
│   ├── utils/        # 仅在需要工具时
│   └── database/     # 仅在处理DB时
```

**实践：**
- 只将相关文件夹添加到提示中
- 不要让AI每次扫描整个代码库
- 您最了解需要什么——而不是AI

**示例对话：**
```
坏："这是我的整个src/文件夹[包含所有内容]"
好："正在处理用户身份验证。包括src/api/auth.ts和src/database/users.ts"
```

### 2. MCP作为上下文节省

**问题：**
没有MCP，您手动获取外部数据并粘贴到对话中。

**没有MCP的示例：**
```
您：*复制粘贴React文档关于useEffect*
    *复制粘贴Stack Overflow答案*
    *粘贴来自Postman的API响应*
    "这是上下文，现在帮我调试"
[仅上下文就使用5000个令牌]
```

**有MCP的示例：**
```
您："使用Context7 MCP检查React useEffect最佳实践，
     然后使用DevTools MCP找到错误"
代理：*通过MCP检索数据，分析，修复*
[使用500个令牌，节省90%]
```

**用于上下文节省的关键MCP：**

| MCP | 通过以下方式节省上下文 |
|-----|-----------------|
| **Context7** | 检索框架/库文档而不是粘贴 |
| **DevTools** | 读取浏览器控制台/网络而不是截图 |
| **Database** | 直接查询数据库而不是手动导出 |
| **API客户端** | 获取API数据而不是复制粘贴 |
| **Filesystem** | 读取日志/文件而不是手动包含 |

**最佳实践：**
- 使用MCP进行外部数据检索
- 不要同时运行太多MCP（增加开销）
- 知道何时MCP有帮助vs.何时手动更快

### 3. 对话压缩

**当对话变长时：**

**选项1：自动（Zed）**
- 代理在上下文填满时创建摘要
- 对话自动压缩
- 无缝继续

**选项2：手动外部化（更好）**
```
您："将我们所做的摘要写入docs/context/session-summary.md"
代理：*写入摘要*
您："开始新对话，读取docs/context/session-summary.md继续"
[最小上下文的新会话]
```

**选项3：手动压缩**
- 定期要求代理摘要
- 从摘要开始新对话
- 不要信任工具自动管理这个

**专业提示：** 尽可能外部化到.md而不是压缩。压缩丢失细节；文件保留所有内容。

### 4. 避免臃肿

**不要：**
- ❌ 将`node_modules`添加到上下文
- ❌ "以防万一"包含所有文件
- ❌ 多次重复相同的指令
- ❌ 一次运行太多MCP服务器
- ❌ 在活动对话中保留已完成的工作
- ❌ 粘贴整个日志文件

**要做：**
- ✅ 只包含相关文件
- ✅ 使用`.cursorrules`或`.clauderules`进行持久指令
- ✅ 使用MCP进行外部数据
- ✅ 偏好模块化架构
- ✅ 将已完成的工作外部化到.md文件
- ✅ Grep日志查找错误，仅包含相关行

### 5. 上下文启动

**有效开始会话：**

**良好的会话开始：**
```
您："读取docs/architecture/overview.md和docs/context/last-session.md，
     然后继续实施docs/plans/auth-feature.md"

代理：*读取3个小文件，有完整上下文，开始工作*
[总上下文：~1000个令牌]
```

**不良的会话开始：**
```
您："所以我们正在构建这个身份验证系统，记得我们讨论过JWT，
     还有那个刷新令牌的事情，我们需要处理
     基于角色的访问，我们讨论了bcrypt vs argon2..."

代理："我没有以前的上下文，您能提供详细信息吗？"
[重复所有内容，使用5000+令牌]
```

### 6. 语义分块

**为AI理解组织信息：**

**不良的.md结构：**
```markdown
# 功能
所有内容在一个巨大的段落中，实现细节与
架构决策与TODO与注意事项混合...
```

**良好的.md结构：**
```markdown
# 功能名称

## 概述
[高级摘要]

## 架构
[设计决策]

## 实现任务
- [ ] 任务1
- [ ] 任务2

## 技术注意事项
- 注意1
- 注意2

## 参考
- 链接1
- 链接2
```

**为什么这很重要：**
- 代理可以扫描标题找到相关部分
- 可以只读取当前任务需要的内容
- 清晰结构 = 更好的理解

### 7. 任务分解

**大任务 → 多个小任务**

**示例："构建用户身份验证"**

不良方法：
```
对话：实施整个身份验证系统
[用所有文件、所有决策、所有边缘情况压倒上下文]
```

良好方法：
```
docs/plans/auth.md:
  - [ ] 数据库模式
  - [ ] 密码哈希
  - [ ] JWT生成
  - [ ] 刷新令牌
  - [ ] 中间件
  - [ ] 测试

对话1："实施docs/plans/auth.md中的任务1"
对话2："实施docs/plans/auth.md中的任务2"
...
```

**好处：**
- 每个对话保持小
- 清晰的进度跟踪
- 容易暂停/恢复
- 可以与多个代理并行化

### 8. 多文件工作流程

**跨大型代码库工作：**

**策略：渐进式上下文加载**

```
阶段1：架构理解
- 读取docs/architecture/overview.md
- 仅读取高级结构文件

阶段2：专注实施
- 仅加载当前功能的文件
- 在上下文中保留架构.md以供参考

阶段3：集成
- 加载接口文件
- 将实现细节保留在外部

阶段4：测试
- 加载测试文件 + 最小实现
- 通过文件路径引用实现
```

**示例工作流程：**
```
您："读取docs/architecture/api-design.md，然后按照
     docs/api/endpoints.md实施POST /users端点"

代理：
1. 读取架构（200个令牌）
2. 读取端点规范（300个令牌）
3. 加载src/api/users.ts（500个令牌）
4. 实施
[总计：~1000个令牌 vs. 加载整个API代码库：~50k令牌]
```

### 9. 文档驱动开发

**使用docs/作为代理记忆：**

**模式：**
```
编码前：
1. 编写docs/architecture/design.md
2. 编写docs/api/endpoints.md
3. 编写docs/database/schema.md

编码期间：
- 代理引用这些文档
- 无需重复解释架构
- 决策被保留

编码后：
- 用实际实现更新文档
- 为将来参考添加docs/guides/how-to-X.md
```

**这创建了一个良性循环：**
```
好文档 → 需要更少上下文 → 更快开发 → 更好文档
```

---

## 上下文管理的文件组织

### 推荐结构

```
project/
├── docs/
│   ├── architecture/          # 系统设计，模式
│   │   ├── overview.md
│   │   ├── api-design.md
│   │   └── database-design.md
│   │
│   ├── plans/                 # 功能计划（openspec输出）
│   │   ├── auth-feature.md
│   │   └── payment-integration.md
│   │
│   ├── proposals/             # 供审查的设计提案
│   │   └── refactor-proposal.md
│   │
│   ├── decisions/             # ADR（架构决策记录）
│   │   ├── 001-database-choice.md
│   │   └── 002-auth-strategy.md
│   │
│   ├── context/               # 会话摘要，交接
│   │   ├── 2024-01-session.md
│   │   └── current-state.md
│   │
│   ├── guides/                # 操作方法，运行手册
│   │   ├── setup.md
│   │   └── deployment.md
│   │
│   └── api/                   # API文档
│       └── endpoints.md
│
├── .tasks/                    # 活动任务分解（droid风格）
│   └── current-sprint.md
│
├── .cursorrules               # 或.clauderules，持久指令
│
└── src/                       # 实际代码
    └── ...
```

### 为什么这个结构有效

**1. 清晰的关注点分离**
- 架构 → 战略决策
- 计划 → 战术执行
- 上下文 → 会话连续性
- 指南 → 操作知识

**2. 代理易于导航**
```
代理需要架构信息 → 读取docs/architecture/
代理需要任务列表 → 读取docs/plans/或.tasks/
代理需要过去上下文 → 读取docs/context/
```

**3. 随项目增长扩展**
- 从最小docs/开始
- 根据需要添加目录
- 永远不会膨胀对话上下文

**4. Git友好**
- 所有文档版本化
- 可以看到决策演变
- 容易回滚坏文档

### 文件命名约定

**使用描述性、面向操作的名称：**

```
好：
- docs/plans/user-authentication-feature.md
- docs/decisions/001-why-postgresql.md
- docs/context/2024-01-15-auth-implementation.md

坏：
- docs/stuff.md
- docs/notes.md
- docs/temp.md
```

**对于编号序列（ADR）：**
```
docs/decisions/
├── 001-database-choice.md
├── 002-api-framework.md
└── 003-deployment-strategy.md
```

**对于基于日期的条目：**
```
docs/context/
├── 2024-01-session.md
├── 2024-02-session.md
└── current-state.md  # ← 始终当前状态
```

---

## 高级策略

### 1. 上下文刷新模式

**决策矩阵：何时重置 vs. 压缩 vs. 外部化**

```
对话质量是否下降？
├─ 是 → 是否有重要的决策/上下文需要保留？
│   ├─ 是 → 外部化到.md，重新开始
│   └─ 否 → 完全重新开始新会话
│
└─ 否 → 上下文是否 > 80%满？
    ├─ 是 → 将未来工作外部化到.md，继续当前任务
    └─ 否 → 按原样继续
```

**模式：**

**模式1：外部化并继续**
```
您："将我们的架构决策摘要写入docs/decisions/api-design.md"
代理：*写入文件*
您：[在同一会话中继续，引用.md而不是对话]
```

**模式2：会话交接**
```
您："将会话摘要写入docs/context/session-1.md，包括
     我们构建了什么，做出了什么决策，以及下一步"
代理：*编写全面摘要*
[开始新会话]
您："读取docs/context/session-1.md并继续下一步"
```

**模式3：硬重置**
```
何时：探索性工作完成，准备干净实施
您：[开始新会话]
您："实施docs/plans/feature.md"
[不需要历史上下文]
```

### 2. 渐进式上下文加载

**从小开始，根据需要扩展**

**反模式：**
```
会话开始：包含所有可能相关的文件（50+文件）
结果：从一开始上下文就膨胀
```

**更好的模式：**
```
会话开始：仅包含架构概述 + 当前任务
步骤1：实施功能 → 加载3-5个相关文件
步骤2：需要集成 → 加载接口文件
步骤3：需要测试 → 加载测试实用程序
结果：上下文有机增长，保持最小
```

**示例：**
```
您："读取docs/architecture/overview.md。我们正在实施用户身份验证。"
代理："明白了。首先是什么？"
您："创建JWT令牌生成。包括src/utils/crypto.ts"
[加载1个文件]
代理：*实施*
您："现在与src/api/auth.ts集成"
[再加载1个文件]
...
```

### 3. 上下文检查点

**在关键里程碑保存状态**

**何时检查点：**
- ✅ 完成主要功能后
- ✅ 开始危险重构前
- ✅ 切换上下文时（前端 → 后端）
- ✅ 工作会话结束
- ✅ 重要决策后

**如何检查点：**
```
您："检查点当前状态：
     1. 将我们完成的写入docs/context/checkpoint-auth.md
     2. 将剩余任务写入docs/plans/auth-remaining.md
     3. 将任何重要决策写入docs/decisions/"

代理：*创建检查点文件*
```

**从检查点恢复：**
```
[几天/几周后]
您："读取docs/context/checkpoint-auth.md并继续
     docs/plans/auth-remaining.md"
代理：*从您离开的地方精确继续*
```

### 4. 会话交接

**多代理或多会话连续性**

**交接模板（docs/context/handoff.md）：**
```markdown
# 会话交接 - [日期]

## 完成了什么
- 实施了X
- 修复了错误Y
- 决定了方法Z

## 当前状态
- 功能X：80%完成
- 剩余：任务A，任务B
- 阻塞在：关于C的决策

## 重要上下文
- 我们正在使用PostgreSQL（见docs/decisions/001-database.md）
- 身份验证流程记录在docs/architecture/auth.md
- API设计在docs/api/endpoints.md

## 下一步
1. 完成任务A（见docs/plans/feature.md第45行）
2. 审查任务B的PR
3. 做出关于C的决策

## 进行中的文件
- src/api/auth.ts（主要实现）
- src/database/users.ts（模式）
- tests/auth.test.ts（70%测试覆盖率）
```

**用法：**
```
您："创建交接文档"
代理：*写入docs/context/handoff.md*

[新会话或不同代理]
您："读取docs/context/handoff.md并继续"
代理：*完全上下文化，继续工作*
```

### 5. 活文档

**保持docs/作为单一真实来源**

**模式：**
```
代码更改 → 更新文档
架构决策 → 更新文档
新模式出现 → 在docs中记录
有学习的错误修复 → 更新文档
```

**为什么这很重要：**
- 代理始终有准确信息
- 代码和文档之间没有漂移
- 未来会话以正确上下文开始
- 团队成员可以从docs/入职

**示例工作流程：**
```
您："实施此功能后，更新docs/architecture/api-design.md
     与实际实现细节"

代理：
1. 实施功能
2. 更新文档以匹配现实
3. 提交代码和文档

结果：文档始终反映当前状态
```

---

## 监控和故障排除

### 上下文麻烦的迹象

**质量下降：**
- ❌ 代理忘记最近的决策
- ❌ 矛盾的建议
- ❌ 要求您重复信息
- ❌ 实施与架构不一致的功能
- ❌ 重复性错误
- ❌ 通用建议而不是项目特定

**性能问题：**
- ❌ 响应时间变慢
- ❌ 中断的不完整响应
- ❌ "匆忙完成"行为
- ❌ 跳过错误处理或边缘情况

**上下文管理失败：**
- ❌ 代理说"我没有足够的上下文"
- ❌ 重复读取相同文件
- ❌ 询问您已解释的项目结构
- ❌ 错过文件之间的明显连接

### 诊断问题

**当质量下降时，问自己：**

1. **我的上下文窗口有多满？**
   - 在您的工具中检查令牌使用情况
   - 如果 > 85%，是时候行动了

2. **我是否在重复自己？**
   - 如果是 → 外部化到.md
   - 创建docs/decisions/或.cursorrules

3. **上下文中是否有太多文件？**
   - 审查包含的文件
   - 移除已完成/不相关的文件
   - 只保留当前任务需要的内容

4. **对话是否太长？**
   - 考虑会话交接
   - 外部化已完成的工作
   - 从摘要重新开始

5. **我是否为工作使用了正确的工具？**
   - 我应该使用MCP服务器吗？
   - 这应该在.md文件中吗？
   - 我应该开始新的专门会话吗？

### 恢复策略

**策略1：立即外部化**
```
问题：代理忘记架构决策
解决方案："将我们的架构决策记录到docs/decisions/api-design.md
          并引用它而不是我再次解释"
```

**策略2：上下文清理**
```
问题：上下文中文件太多
解决方案："移除所有文件。现在只包含src/api/auth.ts和
          docs/architecture/auth.md用于当前任务"
```

**策略3：带交接的会话重置**
```
问题：对话太长，质量下降
解决方案：
1. "将会话摘要写入docs/context/handoff.md"
2. 开始新会话
3. "读取docs/context/handoff.md并继续"
```

**策略4：基于计划的重置**
```
问题：失去总体目标跟踪
解决方案：
1. "根据我们讨论的内容编写实施计划到docs/plans/feature.md"
2. 开始新会话
3. "实施docs/plans/feature.md"
```

**策略5：压缩（最后手段）**
```
问题：无法开始新会话，需要连续性
解决方案："总结我们的对话：我们构建了什么，当前状态，下一步。
          保持在500字以下"
[使用摘要继续或重新开始]
```

### 预防策略

**主动上下文管理：**

1. **从.md文件开始**
   - 实施前编写计划
   - 前期记录架构
   - 为项目约定创建.cursorrules

2. **定期检查点**
   - 每个主要功能后
   - 工作会话结束时
   - 上下文 > 70%满之前

3. **无情的关联性**
   - 只包含现在需要的内容
   - 任务完成时移除文件
   - 不要保留"以防万一"上下文

4. **使用正确的工具**
   - MCP服务器用于外部数据
   - 任务代理用于探索
   - 新会话用于新功能

5. **监控指标**
   - 令牌使用情况
   - 响应质量
   - 完成时间
   - 代理困惑频率

**为自己设置警报：**
```
当上下文 > 60%：审查包含的文件
当上下文 > 75%：计划外部化或重置
当上下文 > 85%：需要立即行动
```

---

## 用于上下文管理的MCP服务器

### 理解MCP的角色

**MCP服务器检索外部数据，因此您不必手动将其粘贴到对话中。**

**上下文节省方程：**
```
没有MCP：
1. 您手动获取数据（浏览器，API，数据库）
2. 复制粘贴到对话中
3. 代理处理
成本：您的时间 + 上下文令牌

有MCP：
1. 代理通过MCP获取数据
2. 代理处理
成本：仅处理令牌（通常更小）
```

### 外部数据检索MCP

**1. Context7 MCP**
- **目的：** 框架/库文档
- **示例：**
  ```
  没有：复制粘贴React文档关于useEffect
  有：    "使用Context7检查React useEffect模式"
  ```
- **节省：** 每次文档引用2000+令牌

**2. DevTools MCP**
- **目的：** 浏览器调试数据
- **示例：**
  ```
  没有：截图控制台，粘贴错误，描述网络选项卡
  有：    "使用DevTools MCP分析错误"
  ```
- **节省：** 每次调试会话3000+令牌

**3. 数据库MCP**
- **目的：** 直接查询数据库
- **示例：**
  ```
  没有：运行查询，导出CSV，粘贴到对话中
  有：    "通过MCP查询用户表以分析数据"
  ```
- **节省：** 每次查询结果1000+令牌

**4. API客户端MCP**
- **目的：** 从外部API获取
- **示例：**
  ```
  没有：使用Postman，复制响应，粘贴到对话中
  有：    "通过MCP获取/api/users并分析响应"
  ```
- **节省：** 每次API调用500+令牌

**5. 文件系统MCP**
- **目的：** 读取日志，配置文件
- **示例：**
  ```
  没有：将整个日志文件复制到对话中
  有：    "使用文件系统MCP在error.log中grep'FATAL'"
  ```
- **节省：** 大型日志文件5000+令牌

### 何时使用MCP

**使用MCP当：**
- ✅ 您需要外部框架/库文档
- ✅ 您需要调试浏览器控制台/网络
- ✅ 您需要查询数据库进行分析
- ✅ 您需要从外部API获取
- ✅ 您需要选择性地读取大型日志文件

**不要使用MCP当：**
- ❌ 信息已在您的代码库中（使用文件读取）
- ❌ 简单的一次性查找（手动可能更快）
- ❌ MCP服务器慢/不可靠（手动可能更好）
- ❌ 您正在运行太多MCP（开销增加）

### 最佳实践

**1. 不要过度依赖MCP**
```
坏：同时运行10个不同的MCP服务器
好：使用2-3个最相关的MCP
```

**2. 知道每个MCP做什么**
```
Context7：外部文档，不是您的项目文档
DevTools：浏览器数据，不是服务器日志
Database：直接查询，不是基于文件的DB
```

**3. 与.md文件结合**
```
您："使用Context7研究最佳实践，然后编写
     提案到docs/proposals/api-design.md"

代理：
1. 通过MCP获取外部知识
2. 将提案写入.md文件
3. 未来会话引用.md，而不是再次MCP
```

**4. 用于探索，外部化发现**
```
探索阶段：
- 使用MCP收集信息
- 代理综合发现

文档阶段：
- 将发现写入docs/research/topic.md
- 从.md将来引用，而不是MCP
```

### 常见MCP反模式

**反模式1：使用MCP进行项目文档**
```
坏："使用Context7了解我们的API设计"
好："读取docs/architecture/api-design.md"
```
Context7用于React/Vue等文档，不是您的项目！

**反模式2：过度依赖**
```
坏：每个问题 → MCP查找
好：创建docs/包含常见知识，MCP用于边缘情况
```

**反模式3：错误工具**
```
坏：使用文件系统MCP读取src/api/auth.ts
好：直接读取文件（更快，更简单）
```

MCP有开销；直接文件读取更适合项目文件。

---

## 最佳实践检查清单

### 开始工作前

- [ ] **将计划/提案写入.md**
   - 使用openspec，droid计划或手动编写
   - 结构：问题 → 方法 → 任务
   - 保存到docs/plans/或docs/proposals/

- [ ] **如果需要，设置docs/结构**
   - 为设计决策创建docs/architecture/
   - 为会话连续性创建docs/context/
   - 为ADR创建docs/decisions/

- [ ] **审查相关现有.md文件**
   - 读取docs/architecture/overview.md
   - 读取docs/context/current-state.md
   - 读取相关docs/decisions/*.md

- [ ] **检查.cursorrules / .clauderules**
   - 项目约定已记录
   - 每会话不重复常见指令
   - 如需要则更新

- [ ] **从最小上下文开始**
   - 只包含立即任务的文件
   - 引用.md文件获取背景信息
   - 计划渐进加载更多文件

### 工作期间

- [ ] **随进度更新任务.md文件**
   - 标记已完成任务
   - 添加关于决策的注意事项
   - 如果方法更改则更新方法

- [ ] **在docs/decisions/中记录决策**
   - 架构选择
   - 技术权衡
   - 非明显实现背后的"为什么"

- [ ] **保持对话专注于当前任务**
   - 一次一个任务
   - 在继续之前完成并外部化
   - 抵制范围蔓延

- [ ] **引用.md文件而不是重复信息**
   ```
   坏："记住我们决定使用PostgreSQL因为..."
   好："根据docs/decisions/001-database.md，我们正在使用PostgreSQL"
   ```

- [ ] **监控上下文使用情况**
   - 定期检查令牌计数
   - 如果 > 70%，计划外部化
   - 如果 > 85%，立即采取行动

- [ ] **仅将MCP用于外部数据**
   - 通过Context7获取框架文档
   - 通过DevTools进行浏览器调试
   - 不用于项目文件

- [ ] **渐进加载上下文**
   - 从2-3个文件开始
   - 仅在需要时添加更多
   - 任务完成时移除文件

### 完成后

- [ ] **将会话摘要写入docs/context/**
   - 完成了什么
   - 做出了什么决策
   - 当前状态
   - 下一步

- [ ] **用学习更新相关docs/**
   - 如果设计更改则更新docs/architecture/
   - 为复杂程序添加docs/guides/
   - 如果端点更改则更新docs/api/

- [ ] **清理临时文件**
   - 移除调试日志
   - 清理测试文件
   - 归档已完成计划

- [ ] **如果需要创建交接文档**
   - 用于多会话工作
   - 用于团队协作
   - 用于将来的您

- [ ] **将文档与代码一起提交**
   ```bash
   git add src/ docs/
   git commit -m "实施功能X，更新架构文档"
   ```

### 定期维护

- [ ] **每月审查docs/结构**
   - 归档旧计划
   - 更新架构文档
   - 整合分散的决策

- [ ] **随着模式出现更新.cursorrules**
   - 新约定
   - 常见陷阱
   - 首选方法

- [ ] **为常见.md文件创建模板**
   - docs/templates/proposal.md
   - docs/templates/decision.md
   - docs/templates/handoff.md

---

## 真实场景

### 场景1：大型功能开发

**上下文：实施完整的用户身份验证系统**

**传统方法：**
```
会话1：
您："让我们构建用户身份验证，使用JWT，刷新令牌，RBAC，电子邮件验证..."
[讨论所有内容：10k令牌]
代理：*开始实施*
[对话包含所有文件，所有决策：100k令牌]
[会话在80%完成时达到上下文限制]

会话2：
您："继续身份验证实施...我们讨论了JWT，刷新令牌..."
[重新解释：5k令牌]
[代理缺少一些上下文，做出冲突选择]
[另外80k令牌]

总计：~195k令牌，不一致实施，上下文痛苦
```

**基于.md的方法：**
```
会话1：
您："让我们计划用户身份验证。使用openspec创建提案。"
代理：*写入docs/plans/auth-feature.md*
[计划：5k令牌]

会话2：
您："实施docs/plans/auth-feature.md - 从数据库模式开始"
代理：*读取计划（500令牌），实施模式*
[实施：8k令牌]

会话3：
您："继续docs/plans/auth-feature.md - JWT生成"
代理：*读取计划（500令牌），实施JWT*
[实施：7k令牌]

...（为每个组件重复）

总计：~40k令牌，一致实施，无上下文问题
节省：~155k令牌（79%减少）
```

### 场景2：多会话项目

**上下文：几天内构建功能**

**没有文档：**
```
第1天：实施50%，工作日结束
第2天："我们在做什么？"
       尝试记住细节
       代理没有上下文
       重新解释所有内容：10k令牌
       浪费30分钟回到流程

第3天：类似问题，记忆更差
       更多重新解释
       代理做出与第1天冲突的决策
       必须重做工作
```

**使用docs/context/交接：**
```
第1天：
- 实施50%
- 结束："将交接写入docs/context/auth-day1.md"
- 代理写入：已完成工作，决策，下一步

第2天：
- 开始："读取docs/context/auth-day1.md并继续"
- 代理在2分钟内有完整上下文
- 零浪费时间，完美连续性

第3天：
- 开始："读取docs/context/auth-day2.md并继续"
- 无缝继续
- 整个过程中决策一致
```

### 场景3：框架文档查找

**上下文：需要理解React hooks最佳实践**

**没有MCP：**
```
您：
1. 打开浏览器
2. 搜索"react useEffect最佳实践"
3. 阅读文章
4. 复制粘贴相关部分
5. 粘贴到对话中：2000令牌

代理：分析粘贴内容，提供答案

总计：您的时间 + 2000令牌
```

**使用Context7 MCP：**
```
您："使用Context7检查React useEffect最佳实践，用于
     清理函数，然后在src/components/DataFetcher.tsx中
     实施适当的清理"

代理：
1. 查询Context7 MCP获取React文档
2. 分析最佳实践
3. 实施适当清理

总计：代理时间 + 300令牌
节省：您的时间 + 1700令牌
```

### 场景4：调试复杂问题

**上下文：奇怪的身份验证错误**

**臃肿方法：**
```
包含在上下文中：
- 所有身份验证文件（10个文件）
- 所有用户相关文件（15个文件）
- 数据库模式
- API路由
- 完整错误日志
- 网络跟踪

总上下文：~80k令牌
代理：不知所措，建议通用调试步骤
```

**专注方法与渐进加载：**
```
开始：
- 错误消息
- src/api/auth.ts（错误发生处）
总计：2k令牌

代理："检查令牌验证"
您："添加src/utils/jwt.ts"
总计：3k令牌

代理："发现问题 - 过期令牌未处理"
您："添加tests/auth.test.ts验证修复"
总计：5k令牌

结果：发现并修复问题，使用5k令牌 vs 80k令牌
节省：75k令牌（94%减少）
```

### 场景5：大型PR的代码审查

**上下文：审查有50个文件更改的PR**

**一次性方法：**
```
将所有50个文件加载到上下文中
尝试一次审查所有内容
上下文：100k令牌
代理：表面级审查，错过重要细节
质量：低（被数量压倒）
```

**检查清单驱动方法：**
```
步骤1：使用检查清单创建docs/reviews/pr-123.md
- [ ] 安全审查
- [ ] 错误处理
- [ ] 测试覆盖率
- [ ] API设计一致性
- [ ] 性能考虑

步骤2：按类别审查
会话1：安全 - 仅加载身份验证相关文件
会话2：错误处理 - 仅加载更改的逻辑
会话3：测试 - 仅加载测试文件
...

每个会话：10-15k令牌
总计：~50k令牌跨会话
质量：高（专注，每类别彻底审查）
节省：50k令牌 + 更好质量
```

### 场景6：架构重构

**上下文：重构API层架构**

**无计划方法：**
```
您："让我们重构API以使用服务层模式"
代理：开始进行更改
[文件跨会话更改]
[出现不一致模式]
[必须重复解释服务层模式]
[重构需要3周，不一致实施]
```

**文档优先方法：**
```
第1周：计划
- 编写docs/proposals/service-layer-refactor.md
  - 当前问题
  - 提议架构
  - 迁移策略
  - 逐文件计划
- 与团队审查和完善

第2周：执行
会话1："实施docs/proposals/service-layer-refactor.md的步骤1"
会话2："实施docs/proposals/service-layer-refactor.md的步骤2"
...

每个会话：
- 读取提案（500令牌）
- 实施下一步
- 用进度更新提案

结果：一致重构，2周完成，文档良好
```

---

## 快速参考

### 何时外部化到.md

```
问："我是否再次需要此信息？"
├─ 是 → 写入.md文件
└─ 否 → 保留在对话中

问："这是决策还是只是讨论？"
├─ 决策 → docs/decisions/*.md
└─ 讨论 → 对话（短暂）

问："我是否在重复自己？"
├─ 是 → 创建.md，引用它
└─ 否 → 继续对话
```

### 文件位置指南

| 信息类型 | 位置 | 示例 |
|---------|------|------|
| 功能计划 | `docs/plans/` | `auth-feature.md` |
| 架构 | `docs/architecture/` | `api-design.md` |
| 决策 | `docs/decisions/` | `001-database.md` |
| 会话交接 | `docs/context/` | `2024-01-session.md` |
| 操作指南 | `docs/guides/` | `deployment.md` |
| API文档 | `docs/api/` | `endpoints.md` |
| 活动任务 | `.tasks/` | `current-sprint.md` |
| 持久指令 | 根目录 | `.cursorrules` |

### 上下文预算规则

| 使用情况 | 操作 |
|---------|------|
| 0-60% | ✅ 最佳 - 完整质量 |
| 60-75% | ⚠️ 监控 - 考虑外部化 |
| 75-85% | ⚠️ 警告 - 计划尽快重置 |
| 85-95% | 🚨 危险 - 立即外部化 |
| 95-100% | 🛑 关键 - 立即行动 |

### MCP决策树

```
我需要外部数据吗？
├─ 框架/库文档 → Context7 MCP
├─ 浏览器调试 → DevTools MCP
├─ 数据库查询 → 数据库MCP
├─ API调用 → API客户端MCP
└─ 项目文件 → 直接文件读取（不是MCP）
```

## 工作流程集成

**在所有阶段使用：**

**阶段1：计划**
- [PRD和规范管理](../workflow/phase-1-planning.md)的上下文管理
- [OpenSpec CLI](../development-tools/recommended-tools/openspec-cli.md)集成用于计划外部化
- 架构决策记录在[docs/decisions/](./#file-organization-for-context-management)中以供将来参考

**阶段2：开发**
- [Droid CLI](../development-tools/recommended-tools/droid-cli.md)计划/执行工作流程利用.md文件
- 按[开发工作流程](../workflow/phase-2-development.md#feature-by-feature-implementation)的功能逐功能上下文管理
- [Zed IDE](../development-tools/recommended-tools/zed.md)自动压缩和工作流程管理

**阶段3：测试和调试**
- [综合测试](../workflow/phase-3-testing-debugging.md)的调试上下文和错误跟踪
- [DevTools MCP](../development-tools/mcp-servers/devtools-mcp.md)外部化浏览器调试上下文
- 使用[docs/context/](./#session-handoffs)模式在调试会话之间进行会话交接

**阶段4：部署**
- 使用[上下文管理模式](./#multi-session-project)进行项目交接文档
- [客户项目](./#real-world-scenarios)的配置和决策保留
- 通过[活文档](./#living-documentation)进行知识转移

**工具集成：**

**Context7 MCP**
- 外部化框架文档以减少上下文使用
- 与[核心技术](../core-technologies.md)实施集成
- 在架构讨论期间为[AI模型提供商](../ai-model-providers/README.md)节省上下文

**Task Manager MCP**
- 跨[工作流程阶段](../workflow/)的持久任务管理
- 使用[任务分解模式](./#task-decomposition)进行上下文感知任务跟踪
- 与[阶段2开发工作流程](../workflow/phase-2-development.md)集成

**Sequential Thinking MCP**
- 使用[认知增强技术](./#advanced-strategies)增强问题解决上下文
- 在[docs/decisions/](./#file-organization-for-context-management)中保留战略思维
- 与[计划工作流程](../workflow/phase-1-planning.md)集成

**MCP服务器上下文优化：**
- [Context7 MCP](../development-tools/mcp-servers/context7-mcp.md) — 框架文档外部化
- [DevTools MCP](../development-tools/mcp-servers/devtools-mcp.md) — 浏览器调试上下文管理
- [Task Manager MCP](../development-tools/mcp-servers/task-manager-mcp.md) — 持久工作流程上下文
- [Sequential Thinking MCP](../development-tools/mcp-servers/sequential-thinking-mcp.md) — 问题解决上下文
- [Shadcn MCP](../development-tools/mcp-servers/shadcn-mcp.md) — [阶段2开发](../workflow/phase-2-development.md)的UI组件上下文

**业务策略集成：**
- 使用上下文管理最佳实践进行[客户项目交接](./#client-project-considerations)
- 通过高效上下文使用进行[自由职业工作流程优化](../introduction/README.md)
- 通过减少AI令牌消耗进行[成本效益开发](../workflow/phase-0-vibecoder-preparation.md)

**相关文档：**
- 上下文管理集成的[学习路径](../../README.md#learning-path)
- 上下文相关术语的[术语表](../glossary.md)
- 文档中上下文管理的[贡献](../contributing.md)

---

**返回：** [顶级README](../../README.md)

**相关：**
- [开发工具](../development-tools/)
- [核心技术](../core-technologies.md)
- [工作流程](../workflow/)