# Cloudflare R2å­˜å‚¨

## æ¦‚è¿°

Cloudflare R2ï¼ˆRidiculously Resilientï¼‰å­˜å‚¨æ˜¯ä¸€ä¸ªS3å…¼å®¹çš„å¯¹è±¡å­˜å‚¨æœåŠ¡ï¼Œæ—¨åœ¨å­˜å‚¨å¤§é‡éç»“æ„åŒ–æ•°æ®ï¼Œå¦‚å›¾åƒã€è§†é¢‘ã€éŸ³é¢‘æ–‡ä»¶ã€æ–‡æ¡£å’Œå¤‡ä»½ã€‚å…³é”®åŒºåˆ«ï¼š**é›¶å‡ºå£è´¹ç”¨**ã€‚

## ä¸»è¦å¥½å¤„

### é«˜æ€§ä»·æ¯”å­˜å‚¨
- **å…è´¹å±‚çº§10 GBå­˜å‚¨**
- **æ— å‡ºå£è´¹ç”¨**ï¼ˆä¸AWS S3ä¸åŒï¼Œåè€…å¯¹ä¸‹è½½æ”¶è´¹ï¼‰
- **å…è´¹å±‚çº§æ— APIè¯·æ±‚è´¹ç”¨**
- ä»…æŒ‰å­˜å‚¨å’Œæ“ä½œä»˜è´¹ï¼ŒæŒ‰è§„æ¨¡

### S3å…¼å®¹
- **AWS S3çš„ç›´æ¥æ›¿ä»£å“**
- ä½¿ç”¨ç°æœ‰çš„S3åº“å’Œå·¥å…·
- ä»S3æ— ç¼è¿ç§»
- æ ‡å‡†S3 APIå…¼å®¹æ€§

### å¿«é€Ÿå’Œå¯é 
- **é€šè¿‡Cloudflareç½‘ç»œå…¨çƒåˆ†å‘**
- **ä¸Workers/Pagesä¸€èµ·ä½¿ç”¨æ—¶è‡ªåŠ¨ç¼“å­˜**
- **å…·æœ‰è‡ªåŠ¨å¤åˆ¶çš„é«˜å¯ç”¨æ€§**
- **å…¨çƒä½å»¶è¿Ÿè®¿é—®**

### å®Œç¾ç”¨ä¾‹
- **å›¾åƒ/è§†é¢‘æ‰˜ç®¡**ç”¨äºWebåº”ç”¨ç¨‹åº
- **ç”¨æˆ·ç”Ÿæˆå†…å®¹**å­˜å‚¨
- **é™æ€èµ„äº§æ‰˜ç®¡**ï¼ˆCSSã€JSã€å­—ä½“ï¼‰
- **æ•°æ®åº“å’Œæ–‡ä»¶çš„å¤‡ä»½å­˜å‚¨**
- **å†…å®¹å¹³å°çš„åª’ä½“åº“**
- **SaaSåº”ç”¨ç¨‹åºä¸­çš„æ–‡ä»¶ä¸Šä¼ /ä¸‹è½½**åŠŸèƒ½

## å®šä»·

### å…è´¹å±‚çº§
- **åŒ…æ‹¬10 GBå­˜å‚¨**
- **æ¯æœˆ100ä¸‡æ¬¡Aç±»æ“ä½œ**ï¼ˆå†™å…¥ã€åˆ—å‡ºï¼‰
- **æ¯æœˆ1000ä¸‡æ¬¡Bç±»æ“ä½œ**ï¼ˆè¯»å–ï¼‰
- **æ°¸è¿œæ— å‡ºå£è´¹ç”¨ï¼**

### ä»˜è´¹å®šä»·ï¼ˆå½“æ‚¨è¶…è¿‡å…è´¹å±‚çº§æ—¶ï¼‰
- **å­˜å‚¨**ï¼šæ¯GBæ¯æœˆ$0.015ï¼ˆ~æ¯TB $15ï¼‰
- **Aç±»æ“ä½œ**ï¼šæ¯ç™¾ä¸‡$4.50ï¼ˆå†™å…¥ï¼‰
- **Bç±»æ“ä½œ**ï¼šæ¯ç™¾ä¸‡$0.36ï¼ˆè¯»å–ï¼‰
- **å‡ºå£**ï¼š$0ï¼ˆå…è´¹ï¼ï¼‰ğŸ‰

### æˆæœ¬æ¯”è¾ƒ

**ç¤ºä¾‹**ï¼šæä¾›100 GBå›¾åƒï¼Œæ¯æœˆ1 TBä¸‹è½½

| æœåŠ¡                 | å­˜å‚¨  | å‡ºå£    | æ€»è®¡        |
| -------------------- | ----- | ------- | ----------- |
| AWS S3               | $2.30 | $92.00  | **$94.30**  |
| Google Cloud Storage | $2.00 | $120.00 | **$122.00** |
| Cloudflare R2        | $1.50 | $0.00   | **$1.50**   |

**R2åœ¨å†…å®¹äº¤ä»˜æ–¹é¢ä¾¿å®œ60-80å€ï¼**

## å…¥é—¨

### å…ˆå†³æ¡ä»¶
- Cloudflareè´¦æˆ·
- å®‰è£…Wrangler CLIï¼ˆ`npm install -g wrangler`ï¼‰
- å¯¹å¯¹è±¡å­˜å‚¨çš„åŸºæœ¬äº†è§£

### åˆ›å»ºR2å­˜å‚¨æ¡¶

#### é€šè¿‡Wrangler CLI

```bash
# åˆ›å»ºæ–°å­˜å‚¨æ¡¶
wrangler r2 bucket create my-images

# åˆ—å‡ºæ‰€æœ‰å­˜å‚¨æ¡¶
wrangler r2 bucket list

# åˆ é™¤å­˜å‚¨æ¡¶ï¼ˆå½“ä¸ºç©ºæ—¶ï¼‰
wrangler r2 bucket delete my-bucket-name
```

#### é€šè¿‡Cloudflare Dashboard

1. ç™»å½•[Cloudflare Dashboard](https://dash.cloudflare.com)
2. ä»å·¦ä¾§è¾¹æ é€‰æ‹©**R2**
3. å•å‡»**åˆ›å»ºå­˜å‚¨æ¡¶**
4. è¾“å…¥å­˜å‚¨æ¡¶åç§°ï¼ˆä¾‹å¦‚ï¼Œ`my-app-storage`ï¼‰
5. é€‰æ‹©ä½ç½®ï¼ˆå¯é€‰ï¼‰
6. å•å‡»**åˆ›å»ºå­˜å‚¨æ¡¶**

### å­˜å‚¨æ¡¶é…ç½®

```bash
# è®¾ç½®CORSç­–ç•¥ï¼ˆå¦‚æœéœ€è¦ç›´æ¥æµè§ˆå™¨ä¸Šä¼ ï¼‰
wrangler r2 bucket cors put my-images --config cors.json
```

ç¤ºä¾‹CORSé…ç½®ï¼š
```json
{
  "cors_rules": [
    {
      "allowed_origins": ["https://yourdomain.com"],
      "allowed_methods": ["GET", "PUT", "POST", "DELETE"],
      "allowed_headers": ["*"],
      "max_age_seconds": 3600
    }
  ]
}
```

## ä¸Workersä¸€èµ·ä½¿ç”¨R2

### å°†R2ç»‘å®šåˆ°Worker

åœ¨`wrangler.toml`ä¸­ï¼š
```toml
name = "my-worker"
main = "src/index.ts"

[[r2_buckets]]
binding = "STORAGE"
bucket_name = "my-images"
```

### åŸºæœ¬ä¸Šä¼ ç¤ºä¾‹

```typescript
interface Env {
  STORAGE: R2Bucket;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // ä¸Šä¼ æ–‡ä»¶
    if (url.pathname === '/upload' && request.method === 'POST') {
      const formData = await request.formData();
      const file = formData.get('file') as File;

      if (!file) {
        return Response.json({ error: 'No file provided' }, { status: 400 });
      }

      // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
      const filename = `${Date.now()}-${file.name}`;

      // ä¸Šä¼ åˆ°R2
      await env.STORAGE.put(filename, file.stream(), {
        httpMetadata: {
          contentType: file.type,
        },
      });

      return Response.json({
        success: true,
        url: `/files/${filename}`,
        filename,
      });
    }

    // ä¸‹è½½æ–‡ä»¶
    if (url.pathname.startsWith('/files/')) {
      const filename = url.pathname.slice(7);

      const object = await env.STORAGE.get(filename);

      if (!object) {
        return new Response('File not found', { status: 404 });
      }

      const headers = new Headers();
      object.writeHttpMetadata(headers);
      headers.set('etag', object.httpEtag);

      return new Response(object.body, { headers });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

### å¸¦éªŒè¯çš„å›¾åƒä¸Šä¼ 

```typescript
const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
const MAX_SIZE = 5 * 1024 * 1024; // 5MB

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    if (request.method !== 'POST') {
      return Response.json({ error: 'Method not allowed' }, { status: 405 });
    }

    const formData = await request.formData();
    const file = formData.get('image') as File;

    // éªŒè¯æ–‡ä»¶
    if (!file) {
      return Response.json({ error: 'No file provided' }, { status: 400 });
    }

    if (!ALLOWED_TYPES.includes(file.type)) {
      return Response.json({ error: 'Invalid file type' }, { status: 400 });
    }

    if (file.size > MAX_SIZE) {
      return Response.json({ error: 'File too large' }, { status: 400 });
    }

    // ä½¿ç”¨UUIDç”Ÿæˆæ–‡ä»¶å
    const extension = file.name.split('.').pop();
    const filename = `${crypto.randomUUID()}.${extension}`;
    const key = `images/${filename}`;

    // ä¸Šä¼ åˆ°R2
    await env.STORAGE.put(key, file.stream(), {
      httpMetadata: {
        contentType: file.type,
      },
      customMetadata: {
        originalName: file.name,
        uploadedAt: new Date().toISOString(),
      },
    });

    return Response.json({
      success: true,
      url: `https://your-worker.workers.dev/files/${key}`,
      filename,
    });
  },
};
```

### åˆ—å‡ºæ–‡ä»¶

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/api/files') {
      // åˆ—å‡ºæ‰€æœ‰å¯¹è±¡
      const listed = await env.STORAGE.list({
        limit: 10,
        prefix: 'images/', // å¯é€‰ï¼šæŒ‰å‰ç¼€è¿‡æ»¤
      });

      const files = listed.objects.map(obj => ({
        key: obj.key,
        size: obj.size,
        uploaded: obj.uploaded,
      }));

      return Response.json({
        files,
        truncated: listed.truncated,
        cursor: listed.cursor,
      });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

### åˆ é™¤æ–‡ä»¶

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/api/delete' && request.method === 'DELETE') {
      const { filename } = await request.json();

      // ä»R2åˆ é™¤
      await env.STORAGE.delete(filename);

      return Response.json({ success: true });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

## é«˜çº§ç‰¹æ€§

### åˆ†æ®µä¸Šä¼ ï¼ˆå¤§æ–‡ä»¶ï¼‰

å¯¹äºå¤§äº5MBçš„æ–‡ä»¶ï¼Œä½¿ç”¨åˆ†æ®µä¸Šä¼ ï¼š

```typescript
async function uploadLargeFile(file: File, env: Env) {
  const filename = `large-files/${crypto.randomUUID()}-${file.name}`;

  // åˆ›å»ºåˆ†æ®µä¸Šä¼ 
  const multipart = await env.STORAGE.createMultipartUpload(filename);

  const CHUNK_SIZE = 5 * 1024 * 1024; // 5MBå—
  const chunks: R2UploadedPart[] = [];

  let offset = 0;
  let partNumber = 1;

  // åˆ†å—ä¸Šä¼ 
  while (offset < file.size) {
    const chunk = file.slice(offset, offset + CHUNK_SIZE);
    const buffer = await chunk.arrayBuffer();

    const part = await multipart.uploadPart(partNumber, buffer);
    chunks.push(part);

    offset += CHUNK_SIZE;
    partNumber++;
  }

  // å®Œæˆä¸Šä¼ 
  const object = await multipart.complete(chunks);

  return {
    success: true,
    key: filename,
    size: object.size,
  };
}
```

### æ¡ä»¶è¯·æ±‚ï¼ˆç¼“å­˜ï¼‰

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const filename = url.pathname.slice(1);

    const object = await env.STORAGE.get(filename);

    if (!object) {
      return new Response('Not found', { status: 404 });
    }

    // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æœ‰ç¼“å­˜ç‰ˆæœ¬
    const ifNoneMatch = request.headers.get('If-None-Match');
    if (ifNoneMatch === object.httpEtag) {
      return new Response(null, { status: 304 }); // æœªä¿®æ”¹
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);
    headers.set('etag', object.httpEtag);
    headers.set('cache-control', 'public, max-age=31536000'); // 1å¹´

    return new Response(object.body, { headers });
  },
};
```

### è‡ªå®šä¹‰å…ƒæ•°æ®

```typescript
// ä¸æ–‡ä»¶ä¸€èµ·å­˜å‚¨å…ƒæ•°æ®
await env.STORAGE.put('user-123/profile.jpg', file.stream(), {
  httpMetadata: {
    contentType: 'image/jpeg',
  },
  customMetadata: {
    userId: '123',
    uploadedBy: 'john@example.com',
    category: 'profile-pictures',
    originalName: file.name,
  },
});

// æ£€ç´¢å…ƒæ•°æ®
const object = await env.STORAGE.head('user-123/profile.jpg');
console.log(object.customMetadata);
```

## ä¸Pageså‡½æ•°ä¸€èµ·ä½¿ç”¨R2

```typescript
// functions/upload.ts

interface Env {
  STORAGE: R2Bucket;
}

export const onRequestPost: PagesFunction<Env> = async (context) => {
  const formData = await context.request.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return Response.json({ error: 'No file' }, { status: 400 });
  }

  const filename = `${Date.now()}-${file.name}`;

  await context.env.STORAGE.put(filename, file.stream(), {
    httpMetadata: { contentType: file.type },
  });

  return Response.json({ success: true, filename });
};
```

## å…¬å…±å­˜å‚¨æ¡¶è®¿é—®

### å…¬å…±æ–‡ä»¶çš„è‡ªå®šä¹‰åŸŸå

1. åˆ›å»ºå­˜å‚¨æ¡¶ï¼š`my-public-assets`
2. åœ¨R2ä»ªè¡¨æ¿ä¸­æ·»åŠ è‡ªå®šä¹‰åŸŸå
3. é…ç½®DNSï¼ˆå¦‚æœåŸŸååœ¨Cloudflareä¸Šåˆ™è‡ªåŠ¨é…ç½®ï¼‰
4. æ–‡ä»¶å¯é€šè¿‡ä»¥ä¸‹æ–¹å¼è®¿é—®ï¼š`https://cdn.yourdomain.com/filename.jpg`

### Workerä½œä¸ºCDN

ä½¿ç”¨Workeré€šè¿‡è‡ªå®šä¹‰é€»è¾‘æä¾›R2æ–‡ä»¶ï¼š

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const key = url.pathname.slice(1);

    // æ·»åŠ å®‰å…¨æ£€æŸ¥ã€åˆ†æç­‰
    const object = await env.STORAGE.get(key);

    if (!object) {
      return new Response('Not found', { status: 404 });
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);

    // æ·»åŠ è‡ªå®šä¹‰å¤´
    headers.set('Cache-Control', 'public, max-age=86400');
    headers.set('CDN-Cache-Control', 'public, max-age=31536000');

    return new Response(object.body, { headers });
  },
};
```

## S3 APIå…¼å®¹æ€§

R2æ”¯æŒS3 APIï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨AWS SDKï¼š

### è®¾ç½®S3å®¢æˆ·ç«¯

```bash
npm install @aws-sdk/client-s3
```

```typescript
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const S3 = new S3Client({
  region: 'auto',
  endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: 'your-access-key-id',
    secretAccessKey: 'your-secret-access-key',
  },
});

// ä¸Šä¼ æ–‡ä»¶
await S3.send(new PutObjectCommand({
  Bucket: 'my-bucket',
  Key: 'test.jpg',
  Body: fileBuffer,
  ContentType: 'image/jpeg',
}));
```

### ç”Ÿæˆè®¿é—®å¯†é’¥

1. è½¬åˆ°R2ä»ªè¡¨æ¿
2. å•å‡»**ç®¡ç†R2 APIä»¤ç‰Œ**
3. åˆ›å»ºAPIä»¤ç‰Œ
4. ä¿å­˜è®¿é—®å¯†é’¥IDå’Œç§˜å¯†è®¿é—®å¯†é’¥

## ç¡®ä¿å®ƒå·¥ä½œ

### æµ‹è¯•æ£€æŸ¥æ¸…å•

1. **æµ‹è¯•ä¸Šä¼ **:
   ```bash
   curl -X POST https://your-worker.workers.dev/upload \
     -F "file=@test-image.jpg"
   ```

2. **æµ‹è¯•ä¸‹è½½**:
   ```bash
   curl https://your-worker.workers.dev/files/test-image.jpg \
     --output downloaded.jpg
   ```

3. **åœ¨ä»ªè¡¨æ¿ä¸­éªŒè¯**:
   - è½¬åˆ°Cloudflareä»ªè¡¨æ¿ä¸­çš„R2å­˜å‚¨æ¡¶
   - æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åˆ—å‡º
   - éªŒè¯å¤§å°å’Œå…ƒæ•°æ®

4. **æµ‹è¯•åˆ é™¤**:
   ```bash
   curl -X DELETE https://your-worker.workers.dev/api/delete \
     -H "Content-Type: application/json" \
     -d '{"filename": "test-image.jpg"}'
   ```

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

**ä¸Šä¼ é™é»˜å¤±è´¥ï¼š**
- æ£€æŸ¥`wrangler.toml`ä¸­çš„å­˜å‚¨æ¡¶åç§°
- éªŒè¯ç»‘å®šåç§°ä¸ä»£ç åŒ¹é…
- æ£€æŸ¥æ–‡ä»¶å¤§å°é™åˆ¶

**æµè§ˆå™¨ä¸­çš„CORSé”™è¯¯ï¼š**
- åœ¨å­˜å‚¨æ¡¶ä¸Šé…ç½®CORSç­–ç•¥
- æ·»åŠ é€‚å½“çš„`Access-Control-Allow-*`å¤´

**æ–‡ä»¶æ— æ³•è®¿é—®ï¼š**
- æ£€æŸ¥å­˜å‚¨æ¡¶æ˜¯å¦å…¬å¼€æˆ–éœ€è¦Worker
- éªŒè¯è‡ªå®šä¹‰åŸŸåé…ç½®
- æ£€æŸ¥é˜²ç«å¢™/å®‰å…¨è®¾ç½®

## é«˜æ•ˆä½¿ç”¨æŠ€å·§

### 1. ä½¿ç”¨æ–‡ä»¶å¤¹/å‰ç¼€

```typescript
// é€»è¾‘ç»„ç»‡æ–‡ä»¶
await env.STORAGE.put('users/123/avatar.jpg', file);
await env.STORAGE.put('products/456/image-1.jpg', file);
await env.STORAGE.put('documents/2024/report.pdf', file);

// æŒ‰ç±»åˆ«è½»æ¾åˆ—å‡º
const userFiles = await env.STORAGE.list({ prefix: 'users/123/' });
```

### 2. å®ç°ç¼“å­˜

```typescript
// ä¸ºé™æ€èµ„äº§æ·»åŠ ç¼“å­˜å¤´
headers.set('Cache-Control', 'public, max-age=31536000, immutable');
headers.set('CDN-Cache-Control', 'public, max-age=31536000');
```

### 3. ä¸Šä¼ æ—¶ä¼˜åŒ–å›¾åƒ

```typescript
// ä½¿ç”¨Workersè°ƒæ•´å¤§å°/ä¼˜åŒ–å›¾åƒ
import { Image } from '@cloudflare/workers-image';

const image = await Image.load(await file.arrayBuffer());
const optimized = await image
  .resize(1200) // æœ€å¤§å®½åº¦
  .quality(85)
  .toBuffer('jpeg');

await env.STORAGE.put(filename, optimized);
```

### 4. åœ¨D1ä¸­å­˜å‚¨å…ƒæ•°æ®

```typescript
// åœ¨æ•°æ®åº“ä¸­å­˜å‚¨æ–‡ä»¶å…ƒæ•°æ®ä»¥å¿«é€ŸæŸ¥è¯¢
await env.DB.prepare(`
  INSERT INTO files (key, size, type, uploaded_by, created_at)
  VALUES (?, ?, ?, ?)
`).bind(filename, file.size, file.type, userId, Date.now()).run();

// æ— éœ€åˆ—å‡ºR2å³å¯æŸ¥è¯¢æ–‡ä»¶
const files = await env.DB.prepare(`
  SELECT * FROM files WHERE uploaded_by = ? ORDER BY created_at DESC
`).bind(userId).all();
```

### 5. å®ç°ç­¾åURL

```typescript
// ç”Ÿæˆä¸´æ—¶è®¿é—®URL
function generateSignedUrl(key: string, expiresIn: number): string {
  const expires = Date.now() + expiresIn;
  const signature = await crypto.subtle.sign(
    'HMAC',
    await getSigningKey(),
    new TextEncoder().encode(`${key}:${expires}`)
  );

  return `/files/${key}?expires=${expires}&sig=${btoa(String.fromCharCode(...new Uint8Array(signature)))}`;
}
```

## çœŸå®ä¸–ç•Œç”¨ä¾‹

### 1. ç”¨æˆ·å¤´åƒå­˜å‚¨

```typescript
async function uploadAvatar(file: File, userId: string, env: Env) {
  const key = `avatars/${userId}.jpg`;

  await env.STORAGE.put(key, file.stream(), {
    httpMetadata: { contentType: 'image/jpeg' },
    customMetadata: { userId, uploadedAt: new Date().toISOString() },
  });

  await env.DB.prepare(
    'UPDATE users SET avatar_url = ? WHERE id = ?'
  ).bind(`/avatars/${userId}.jpg`, userId).run();

  return { success: true, url: `/avatars/${userId}.jpg` };
}
```

### 2. æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ

```typescript
async function uploadDocument(file: File, folder: string, env: Env) {
  const filename = `${crypto.randomUUID()}.${file.name.split('.').pop()}`;
  const key = `documents/${folder}/${filename}`;

  await env.STORAGE.put(key, file.stream(), {
    httpMetadata: { contentType: file.type },
    customMetadata: {
      originalName: file.name,
      folder,
      uploadedAt: new Date().toISOString(),
    },
  });

  return { key, url: `/files/${key}` };
}
```

### 3. è§†é¢‘å¹³å°å­˜å‚¨

```typescript
async function uploadVideo(file: File, env: Env) {
  // å¯¹å¤§è§†é¢‘ä½¿ç”¨åˆ†æ®µä¸Šä¼ 
  const key = `videos/${crypto.randomUUID()}.mp4`;

  const multipart = await env.STORAGE.createMultipartUpload(key);

  // åˆ†å—ä¸Šä¼ ï¼ˆä¸Šé¢çš„åˆ†æ®µç¤ºä¾‹ä¸­çš„å®ç°ï¼‰
  // ...

  return { key, url: `/videos/${key}` };
}
```

## ä¸å…¶ä»–æœåŠ¡é›†æˆ

### ä¸Workers
- é€šè¿‡è‡ªå®šä¹‰CDNé€»è¾‘æä¾›æ–‡ä»¶
- æ·»åŠ èº«ä»½éªŒè¯/æˆæƒ
- å®ç°ä½¿ç”¨æƒ…å†µè·Ÿè¸ª

### ä¸Pages
- å­˜å‚¨å‰ç«¯çš„ç”¨æˆ·ä¸Šä¼ 
- æä¾›é™æ€èµ„äº§
- å¤„ç†å¸¦æ–‡ä»¶ä¸Šä¼ çš„è¡¨å•æäº¤

### ä¸D1
- å­˜å‚¨ç”¨äºæŸ¥è¯¢çš„æ–‡ä»¶å…ƒæ•°æ®
- è·Ÿè¸ªæ–‡ä»¶ä½¿ç”¨æƒ…å†µå’Œåˆ†æ
- å®ç°æ–‡ä»¶æƒé™

### ä¸KV
- ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ–‡ä»¶å…ƒæ•°æ®
- å­˜å‚¨ä¸´æ—¶ä¸Šä¼ ä»¤ç‰Œ
- å®ç°é€Ÿç‡é™åˆ¶

## å®˜æ–¹èµ„æº

- **æ–‡æ¡£**: https://developers.cloudflare.com/r2/
- **APIå‚è€ƒ**: https://developers.cloudflare.com/r2/api/
- **å®šä»·**: https://developers.cloudflare.com/r2/pricing/
- **ç¤ºä¾‹**: https://developers.cloudflare.com/r2/examples/
- **Discordç¤¾åŒº**: https://discord.cloudflare.com

## ä¸ºä»€ä¹ˆR2é€‚åˆç°ä»£åº”ç”¨

1. **æ— å‡ºå£è´¹ç”¨** - èŠ‚çœ90%çš„å¸¦å®½æˆæœ¬
2. **S3å…¼å®¹** - ä»AWSè½»æ¾è¿ç§»
3. **å…¨çƒå¿«é€Ÿ** - Cloudflareçš„ç½‘ç»œ
4. **æ…·æ…¨çš„å…è´¹å±‚çº§** - 10GBå…è´¹
5. **Workeré›†æˆ** - è¾¹ç¼˜çš„è‡ªå®šä¹‰é€»è¾‘
6. **ç®€å•å®šä»·** - æ— æ„å¤–è´¦å•
7. **å¯é å­˜å‚¨** - ä¼ä¸šçº§åŸºç¡€è®¾æ–½

å¯¹äºä»»ä½•éœ€è¦å­˜å‚¨å’Œæä¾›æ–‡ä»¶çš„åº”ç”¨ç¨‹åº - å›¾åƒã€è§†é¢‘ã€æ–‡æ¡£ã€å¤‡ä»½ - Cloudflare R2æä¾›æ— ä¸ä¼¦æ¯”çš„ä»·å€¼å’Œæ€§èƒ½ã€‚
{
  "cors_rules": [
    {
      "allowed_origins": ["https://yourdomain.com"],
      "allowed_methods": ["GET", "PUT", "POST", "DELETE"],
      "allowed_headers": ["*"],
      "max_age_seconds": 3600
    }
  ]
}
```

## åœ¨Workersä¸­ä½¿ç”¨R2

### å°†R2ç»‘å®šåˆ°Worker

åœ¨`wrangler.toml`ä¸­ï¼š
```toml
name = "my-worker"
main = "src/index.ts"

[[r2_buckets]]
binding = "STORAGE"
bucket_name = "my-images"
```

### åŸºæœ¬ä¸Šä¼ ç¤ºä¾‹

```typescript
interface Env {
  STORAGE: R2Bucket;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // ä¸Šä¼ æ–‡ä»¶
    if (url.pathname === '/upload' && request.method === 'POST') {
      const formData = await request.formData();
      const file = formData.get('file') as File;

      if (!file) {
        return Response.json({ error: 'No file provided' }, { status: 400 });
      }

      // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
      const filename = `${Date.now()}-${file.name}`;

      // ä¸Šä¼ åˆ°R2
      await env.STORAGE.put(filename, file.stream(), {
        httpMetadata: {
          contentType: file.type,
        },
      });

      return Response.json({
        success: true,
        url: `/files/${filename}`,
        filename,
      });
    }

    // ä¸‹è½½æ–‡ä»¶
    if (url.pathname.startsWith('/files/')) {
      const filename = url.pathname.slice(7);

      const object = await env.STORAGE.get(filename);

      if (!object) {
        return new Response('File not found', { status: 404 });
      }

      const headers = new Headers();
      object.writeHttpMetadata(headers);
      headers.set('etag', object.httpEtag);

      return new Response(object.body, { headers });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

### å¸¦éªŒè¯çš„å›¾åƒä¸Šä¼ 

```typescript
const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
const MAX_SIZE = 5 * 1024 * 1024; // 5MB

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    if (request.method !== 'POST') {
      return Response.json({ error: 'Method not allowed' }, { status: 405 });
    }

    const formData = await request.formData();
    const file = formData.get('image') as File;

    // éªŒè¯æ–‡ä»¶
    if (!file) {
      return Response.json({ error: 'No file provided' }, { status: 400 });
    }

    if (!ALLOWED_TYPES.includes(file.type)) {
      return Response.json({ error: 'Invalid file type' }, { status: 400 });
    }

    if (file.size > MAX_SIZE) {
      return Response.json({ error: 'File too large' }, { status: 400 });
    }

    // ä½¿ç”¨UUIDç”Ÿæˆæ–‡ä»¶å
    const extension = file.name.split('.').pop();
    const filename = `${crypto.randomUUID()}.${extension}`;
    const key = `images/${filename}`;

    // ä¸Šä¼ åˆ°R2
    await env.STORAGE.put(key, file.stream(), {
      httpMetadata: {
        contentType: file.type,
      },
      customMetadata: {
        originalName: file.name,
        uploadedAt: new Date().toISOString(),
      },
    });

    return Response.json({
      success: true,
      url: `https://your-worker.workers.dev/files/${key}`,
      filename,
    });
  },
};
```

### åˆ—å‡ºæ–‡ä»¶

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/api/files') {
      // åˆ—å‡ºæ‰€æœ‰å¯¹è±¡
      const listed = await env.STORAGE.list({
        limit: 100,
        prefix: 'images/', // å¯é€‰ï¼šæŒ‰å‰ç¼€è¿‡æ»¤
      });

      const files = listed.objects.map(obj => ({
        key: obj.key,
        size: obj.size,
        uploaded: obj.uploaded,
      }));

      return Response.json({
        files,
        truncated: listed.truncated,
        cursor: listed.cursor,
      });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

### åˆ é™¤æ–‡ä»¶

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname === '/api/delete' && request.method === 'DELETE') {
      const { filename } = await request.json();

      // ä»R2åˆ é™¤
      await env.STORAGE.delete(filename);

      return Response.json({ success: true });
    }

    return new Response('Not found', { status: 404 });
  },
};
```

## é«˜çº§åŠŸèƒ½

### å¤šéƒ¨åˆ†ä¸Šä¼ ï¼ˆå¤§æ–‡ä»¶ï¼‰

å¯¹äºå¤§äº5MBçš„æ–‡ä»¶ï¼Œä½¿ç”¨å¤šéƒ¨åˆ†ä¸Šä¼ ï¼š

```typescript
async function uploadLargeFile(file: File, env: Env) {
  const filename = `large-files/${crypto.randomUUID()}-${file.name}`;

  // åˆ›å»ºå¤šéƒ¨åˆ†ä¸Šä¼ 
  const multipart = await env.STORAGE.createMultipartUpload(filename);

  const CHUNK_SIZE = 5 * 1024 * 1024; // 5MBå—
  const chunks: R2UploadedPart[] = [];

  let offset = 0;
  let partNumber = 1;

  // åˆ†å—ä¸Šä¼ 
  while (offset < file.size) {
    const chunk = file.slice(offset, offset + CHUNK_SIZE);
    const buffer = await chunk.arrayBuffer();

    const part = await multipart.uploadPart(partNumber, buffer);
    chunks.push(part);

    offset += CHUNK_SIZE;
    partNumber++;
  }

  // å®Œæˆä¸Šä¼ 
  const object = await multipart.complete(chunks);

  return {
    success: true,
    key: filename,
    size: object.size,
  };
}
```

### æ¡ä»¶è¯·æ±‚ï¼ˆç¼“å­˜ï¼‰

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const filename = url.pathname.slice(1);

    const object = await env.STORAGE.get(filename);

    if (!object) {
      return new Response('Not found', { status: 404 });
    }

    // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦æœ‰ç¼“å­˜ç‰ˆæœ¬
    const ifNoneMatch = request.headers.get('If-None-Match');
    if (ifNoneMatch === object.httpEtag) {
      return new Response(null, { status: 304 }); // Not Modified
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);
    headers.set('etag', object.httpEtag);
    headers.set('cache-control', 'public, max-age=31536000'); // 1å¹´

    return new Response(object.body, { headers });
  },
};
```

### è‡ªå®šä¹‰å…ƒæ•°æ®

```typescript
// ä½¿ç”¨æ–‡ä»¶å­˜å‚¨å…ƒæ•°æ®
await env.STORAGE.put('user-123/profile.jpg', file.stream(), {
  httpMetadata: {
    contentType: 'image/jpeg',
  },
  customMetadata: {
    userId: '123',
    uploadedBy: 'john@example.com',
    category: 'profile-pictures',
    originalName: file.name,
  },
});

// æ£€ç´¢å…ƒæ•°æ®
const object = await env.STORAGE.head('user-123/profile.jpg');
console.log(object.customMetadata);
```

## åœ¨Pages Functionsä¸­ä½¿ç”¨R2

```typescript
// functions/upload.ts

interface Env {
  STORAGE: R2Bucket;
}

export const onRequestPost: PagesFunction<Env> = async (context) => {
  const formData = await context.request.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return Response.json({ error: 'No file' }, { status: 400 });
  }

  const filename = `${Date.now()}-${file.name}`;

  await context.env.STORAGE.put(filename, file.stream(), {
    httpMetadata: { contentType: file.type },
  });

  return Response.json({ success: true, filename });
};
```

## å…¬å…±å­˜å‚¨æ¡¶è®¿é—®

### å…¬å…±æ–‡ä»¶çš„è‡ªå®šä¹‰åŸŸå

1. åˆ›å»ºå­˜å‚¨æ¡¶ï¼š`my-public-assets`
2. åœ¨R2ä»ªè¡¨æ¿ä¸­æ·»åŠ è‡ªå®šä¹‰åŸŸå
3. é…ç½®DNSï¼ˆå¦‚æœåŸŸååœ¨Cloudflareä¸Šåˆ™è‡ªåŠ¨ï¼‰
4. æ–‡ä»¶å¯è®¿é—®äºï¼š`https://cdn.yourdomain.com/filename.jpg`

### Workerä½œä¸ºCDN

ä½¿ç”¨Workeré€šè¿‡è‡ªå®šä¹‰é€»è¾‘æä¾›R2æ–‡ä»¶ï¼š

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const key = url.pathname.slice(1);

    // æ·»åŠ å®‰å…¨æ£€æŸ¥ã€åˆ†æç­‰
    const object = await env.STORAGE.get(key);

    if (!object) {
      return new Response('Not found', { status: 404 });
    }

    const headers = new Headers();
    object.writeHttpMetadata(headers);

    // æ·»åŠ è‡ªå®šä¹‰å¤´
    headers.set('Cache-Control', 'public, max-age=86400');
    headers.set('CDN-Cache-Control', 'public, max-age=31536000');

    return new Response(object.body, { headers });
  },
};
```

## S3 APIå…¼å®¹æ€§

R2æ”¯æŒS3 APIï¼Œå› æ­¤æ‚¨å¯ä»¥ä½¿ç”¨AWS SDKï¼š

### è®¾ç½®S3å®¢æˆ·ç«¯

```bash
npm install @aws-sdk/client-s3
```

```typescript
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const S3 = new S3Client({
  region: 'auto',
  endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
  credentials: {
    accessKeyId: 'your-access-key-id',
    secretAccessKey: 'your-secret-access-key',
  },
});

// ä¸Šä¼ æ–‡ä»¶
await S3.send(new PutObjectCommand({
  Bucket: 'my-bucket',
  Key: 'test.jpg',
  Body: fileBuffer,
  ContentType: 'image/jpeg',
}));
```

### ç”Ÿæˆè®¿é—®å¯†é’¥

1. è½¬åˆ°R2ä»ªè¡¨æ¿
2. å•å‡»**Manage R2 API Tokens**
3. åˆ›å»ºAPIä»¤ç‰Œ
4. ä¿å­˜è®¿é—®å¯†é’¥IDå’Œç§˜å¯†è®¿é—®å¯†é’¥

## ç¡®ä¿å®ƒå·¥ä½œ

### æµ‹è¯•æ¸…å•

1. **æµ‹è¯•ä¸Šä¼ **ï¼š
   ```bash
   curl -X POST https://your-worker.workers.dev/upload \
     -F "file=@test-image.jpg"
   ```

2. **æµ‹è¯•ä¸‹è½½**ï¼š
   ```bash
   curl https://your-worker.workers.dev/files/test-image.jpg \
     --output downloaded.jpg
   ```

3. **åœ¨ä»ªè¡¨æ¿ä¸­éªŒè¯**ï¼š
   - è½¬åˆ°Cloudflareä»ªè¡¨æ¿ä¸­çš„R2å­˜å‚¨æ¡¶
   - æ£€æŸ¥æ–‡ä»¶å·²åˆ—å‡º
   - éªŒè¯å¤§å°å’Œå…ƒæ•°æ®

4. **æµ‹è¯•åˆ é™¤**ï¼š
   ```bash
   curl -X DELETE https://your-worker.workers.dev/api/delete \
     -H "Content-Type: application/json" \
     -d '{"filename": "test-image.jpg"}'
   ```

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

**ä¸Šä¼ é™é»˜å¤±è´¥ï¼š**
- æ£€æŸ¥`wrangler.toml`ä¸­çš„å­˜å‚¨æ¡¶åç§°
- éªŒè¯ç»‘å®šåç§°ä¸ä»£ç åŒ¹é…
- æ£€æŸ¥æ–‡ä»¶å¤§å°é™åˆ¶

**æµè§ˆå™¨ä¸­çš„CORSé”™è¯¯ï¼š**
- åœ¨å­˜å‚¨æ¡¶ä¸Šé…ç½®CORSç­–ç•¥
- æ·»åŠ é€‚å½“çš„`Access-Control-Allow-*`å¤´

**æ–‡ä»¶æ— æ³•è®¿é—®ï¼š**
- æ£€æŸ¥å­˜å‚¨æ¡¶æ˜¯å…¬å…±çš„è¿˜æ˜¯éœ€è¦Worker
- éªŒè¯è‡ªå®šä¹‰åŸŸåé…ç½®
- æ£€æŸ¥é˜²ç«å¢™/å®‰å…¨è®¾ç½®

## é«˜æ•ˆä½¿ç”¨æç¤º

### 1. ä½¿ç”¨æ–‡ä»¶å¤¹/å‰ç¼€

```typescript
// é€»è¾‘ç»„ç»‡æ–‡ä»¶
await env.STORAGE.put('users/123/avatar.jpg', file);
await env.STORAGE.put('products/456/image-1.jpg', file);
await env.STORAGE.put('documents/2024/report.pdf', file);

// æŒ‰ç±»åˆ«è½»æ¾åˆ—å‡º
const userFiles = await env.STORAGE.list({ prefix: 'users/123/' });
```

### 2. å®æ–½ç¼“å­˜

```typescript
// ä¸ºé™æ€èµ„äº§æ·»åŠ ç¼“å­˜å¤´
headers.set('Cache-Control', 'public, max-age=31536000, immutable');
headers.set('CDN-Cache-Control', 'public, max-age=31536000');
```

### 3. ä¸Šä¼ æ—¶ä¼˜åŒ–å›¾åƒ

```typescript
// ä½¿ç”¨Workersè°ƒæ•´å¤§å°/ä¼˜åŒ–å›¾åƒ
import { Image } from '@cloudflare/workers-image';

const image = await Image.load(await file.arrayBuffer());
const optimized = await image
  .resize(1200) // æœ€å¤§å®½åº¦
  .quality(85)
  .toBuffer('jpeg');

await env.STORAGE.put(filename, optimized);
```

### 4. åœ¨D1ä¸­å­˜å‚¨å…ƒæ•°æ®

```typescript
// åœ¨æ•°æ®åº“ä¸­å­˜å‚¨æ–‡ä»¶å…ƒæ•°æ®ä»¥è¿›è¡Œå¿«é€ŸæŸ¥è¯¢
await env.DB.prepare(`
  INSERT INTO files (key, size, type, uploaded_by, created_at)
  VALUES (?, ?, ?, ?, ?)
`).bind(filename, file.size, file.type, userId, Date.now()).run();

// æ— éœ€åˆ—å‡ºR2å³å¯æŸ¥è¯¢æ–‡ä»¶
const files = await env.DB.prepare(`
  SELECT * FROM files WHERE uploaded_by = ? ORDER BY created_at DESC
`).bind(userId).all();
```

### 5. å®æ–½ç­¾åURL

```typescript
// ç”Ÿæˆä¸´æ—¶è®¿é—®URL
function generateSignedUrl(key: string, expiresIn: number): string {
  const expires = Date.now() + expiresIn;
  const signature = await crypto.subtle.sign(
    'HMAC',
    await getSigningKey(),
    new TextEncoder().encode(`${key}:${expires}`)
  );

  return `/files/${key}?expires=${expires}&sig=${btoa(String.fromCharCode(...new Uint8Array(signature)))}`;
}
```

## çœŸå®ä¸–ç•Œç”¨ä¾‹

### 1. ç”¨æˆ·å¤´åƒå­˜å‚¨

```typescript
async function uploadAvatar(file: File, userId: string, env: Env) {
  const key = `avatars/${userId}.jpg`;

  await env.STORAGE.put(key, file.stream(), {
    httpMetadata: { contentType: 'image/jpeg' },
    customMetadata: { userId, uploadedAt: new Date().toISOString() },
  });

  await env.DB.prepare(
    'UPDATE users SET avatar_url = ? WHERE id = ?'
  ).bind(`/avatars/${userId}.jpg`, userId).run();

  return { success: true, url: `/avatars/${userId}.jpg` };
}
```

### 2. æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ

```typescript
async function uploadDocument(file: File, folder: string, env: Env) {
  const filename = `${crypto.randomUUID()}.${file.name.split('.').pop()}`;
  const key = `documents/${folder}/${filename}`;

  await env.STORAGE.put(key, file.stream(), {
    httpMetadata: { contentType: file.type },
    customMetadata: {
      originalName: file.name,
      folder,
      uploadedAt: new Date().toISOString(),
    },
  });

  return { key, url: `/files/${key}` };
}
```

### 3. è§†é¢‘å¹³å°å­˜å‚¨

```typescript
async function uploadVideo(file: File, env: Env) {
  // å¯¹å¤§è§†é¢‘ä½¿ç”¨å¤šéƒ¨åˆ†ä¸Šä¼ 
  const key = `videos/${crypto.randomUUID()}.mp4`;

  const multipart = await env.STORAGE.createMultipartUpload(key);

  // åˆ†å—ä¸Šä¼ ï¼ˆæ¥è‡ªä¸Šé¢çš„å¤šéƒ¨åˆ†ç¤ºä¾‹çš„å®ç°ï¼‰
  // ...

  return { key, url: `/videos/${key}` };
}
```

## ä¸å…¶ä»–æœåŠ¡çš„é›†æˆ

### ä¸Workers
- é€šè¿‡è‡ªå®šä¹‰CDNé€»è¾‘æä¾›æ–‡ä»¶
- æ·»åŠ èº«ä»½éªŒè¯/æˆæƒ
- å®æ–½ä½¿ç”¨è·Ÿè¸ª

### ä¸Pages
- ä»å‰ç«¯å­˜å‚¨ç”¨æˆ·ä¸Šä¼ 
- æä¾›é™æ€èµ„äº§
- å¤„ç†å¸¦æœ‰æ–‡ä»¶ä¸Šä¼ çš„è¡¨å•æäº¤

### ä¸D1
- å­˜å‚¨æ–‡ä»¶å…ƒæ•°æ®ä»¥è¿›è¡ŒæŸ¥è¯¢
- è·Ÿè¸ªæ–‡ä»¶ä½¿ç”¨å’Œåˆ†æ
- å®æ–½æ–‡ä»¶æƒé™

### ä¸KV
- ç¼“å­˜é¢‘ç¹è®¿é—®çš„æ–‡ä»¶å…ƒæ•°æ®
- å­˜å‚¨ä¸´æ—¶ä¸Šä¼ ä»¤ç‰Œ
- å®æ–½é€Ÿç‡é™åˆ¶

## å®˜æ–¹èµ„æº

- **æ–‡æ¡£**ï¼šhttps://developers.cloudflare.com/r2/
- **APIå‚è€ƒ**ï¼šhttps://developers.cloudflare.com/r2/api/
- **å®šä»·**ï¼šhttps://developers.cloudflare.com/r2/pricing/
- **ç¤ºä¾‹**ï¼šhttps://developers.cloudflare.com/r2/examples/
- **Discordç¤¾åŒº**ï¼šhttps://discord.cloudflare.com

## ä¸ºä»€ä¹ˆR2éå¸¸é€‚åˆç°ä»£åº”ç”¨ç¨‹åº

1. **æ— å‡ºå£è´¹ç”¨** - åœ¨å¸¦å®½æˆæœ¬ä¸ŠèŠ‚çœ90%
2. **S3å…¼å®¹** - ä»AWSè½»æ¾è¿ç§»
3. **å…¨çƒå¿«é€Ÿ** - Cloudflareçš„ç½‘ç»œ
4. **æ…·æ…¨çš„å…è´¹å±‚çº§** - 10GBå…è´¹
5. **Workeré›†æˆ** - è¾¹ç¼˜çš„è‡ªå®šä¹‰é€»è¾‘
6. **ç®€å•å®šä»·** - æ— æ„å¤–è´¦å•
7. **å¯é å­˜å‚¨** - ä¼ä¸šçº§åŸºç¡€è®¾æ–½

å¯¹äºä»»ä½•éœ€è¦å­˜å‚¨å’Œæä¾›æ–‡ä»¶çš„åº”ç”¨ç¨‹åºâ€”â€”å›¾åƒã€è§†é¢‘ã€æ–‡æ¡£ã€å¤‡ä»½â€”â€”Cloudflare R2æä¾›æ— ä¸ä¼¦æ¯”çš„ä»·å€¼å’Œæ€§èƒ½ã€‚