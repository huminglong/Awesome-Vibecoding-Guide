# 提示工程基础 🎯

**掌握与AI编码助手有效沟通的基础**

---

## 目录

1. [介绍](#介绍)
2. [好提示的解剖](#好提示的解剖)
3. [通用原则](#通用原则)
4. [上下文加载策略](#上下文加载策略)
5. [常见反模式](#常见反模式)
6. [提示演变](#提示演变)
7. [衡量提示质量](#衡量提示质量)
8. [最佳实践检查清单](#最佳实践检查清单)

---

## 介绍

### 为什么提示工程在Vibecoding中很重要

**现实**：您使用AI的编码速度与您的提示技能成正比。

```
模糊提示 → 10次迭代 → 浪费30分钟 → 沮丧的开发人员
清晰提示 → 1-2次迭代 → 总共5分钟 → 高效的开发人员
```

**经济学**：
- **糟糕的提示**：3,000令牌 × 10次迭代 = 30,000令牌 = $0.60 + 您的时间
- **好的提示**：500令牌 × 2次迭代 = 1,000令牌 = $0.02 + 最少时间

**成本节省**：令牌减少97%，实施速度快6倍

**本指南教您**：如何始终如一地编写在第一次或第二次尝试中获得高质量代码的提示。

---

## 好提示的解剖

### 四组件框架

每个有效的提示都有四个元素：

```
┌─────────────────────────────────────────────┐
│         有效的编码提示             │
├─────────────────────────────────────────────┤
│  1. 清晰度      │  您想要什么           │
│  2. 上下文      │  AI需要知道什么   │
│  3. 约束  │  边界和要求│
│  4. 标准     │  如何验证成功   │
└─────────────────────────────────────────────┘
```

### 1. 清晰度：您想要什么

**定义**：对期望结果的特定、无歧义的描述。

**糟糕（模糊）：**
```
"修复身份验证"
```

**为什么失败**：
- 需要修复什么？登录？注册？密码重置？
- 什么坏了？错误？性能？安全？
- 哪些文件？哪些函数？

**良好（清晰）：**
```
"修复src/auth/middleware.ts中的JWT令牌过期处理。
目前，过期令牌返回500错误而不是401未授权。"
```

**为什么有效**：
- ✅ 特定文件和函数
- ✅ 清晰的问题陈述
- ✅ 定义了期望行为
- ✅ 描述了当前行为

---

### 2. 上下文：AI需要知道什么

**定义**：关于您的项目、架构和约定的相关信息。

**上下文类型**：

```
┌──────────────────────────────────────┐
│  项目上下文类型               │
├──────────────────────────────────────┤
│  • 架构模式             │
│  • 技术栈特定              │
│  • 编码约定                │
│  • 相关文件/函数           │
│  • 业务逻辑约束        │
│  • 以前的决策                │
└──────────────────────────────────────┘
```

**示例：**

**糟糕（无上下文）：**
```
"添加用户注册端点"
```

**良好（有上下文）：**
```
"在src/api/auth.ts中添加用户注册端点，遵循src/api/posts.ts中使用的模式。
使用我们现有的来自src/middleware/validation.ts的ValidationMiddleware。
数据库架构在src/models/User.ts中。
我们使用bcrypt进行密码哈希（示例见src/utils/crypto.ts）。"
```

**上下文来源：**
- 文档文件（`docs/architecture/*.md`）
- 现有代码模式（参考类似实现）
- `.cursorrules`或`.clauderules`（项目约定）
- ADR（架构决策记录）

---

### 3. 约束：边界和要求

**定义**：必须遵循的规则、限制和要求。

**常见约束类型：**

```
技术约束：
├─ 性能要求
├─ 安全要求
├─ 兼容性要求
├─ 依赖限制
└─ 资源限制

业务约束：
├─ 法律/合规要求
├─ 用户体验要求
├─ 时间考虑
└─ 预算限制

代码质量约束：
├─ 测试覆盖率要求
├─ 代码风格指南
├─ 文档要求
└─ 可维护性标准
```

**示例：**

**无约束：**
```
"创建文件上传功能"
```

**有约束：**
```
"创建具有这些约束的文件上传功能：
- 最大文件大小：10MB
- 允许类型：仅PDF、PNG、JPG
- 必须在服务器端验证文件类型（不仅仅是扩展名）
- 对>1MB的文件使用流式上传以避免内存问题
- 必须与我们现有的S3兼容存储（Cloudflare R2）一起工作
- 错误消息必须用户友好，而不是技术性的
- 必须包含>2MB上传的进度指示器
- 安全：实施CSRF保护
- 必须编写集成测试"
```

**为什么约束重要：**
- 防止过度工程化
- 确保考虑安全性
- 指导架构决策
- 设置清晰的范围边界

---

### 4. 成功标准：如何验证

**定义**：确定实现是否正确的具体、可衡量的方法。

**成功标准类型：**

```
功能标准：
├─ 期望行为描述
├─ 必须通过的测试场景
├─ 要处理的边缘情况
└─ 集成要求

质量标准：
├─ 性能指标
├─ 安全检查
├─ 代码覆盖率目标
└─ 可访问性标准

用户体验标准：
├─ UI/UX要求
├─ 错误消息质量
├─ 加载状态
└─ 响应行为
```

**示例：**

**无成功标准：**
```
"为用户列表实现分页"
```

**有成功标准：**
```
"为用户列表实现分页。成功意味着：

功能：
- 每页显示20个用户
- 导航工作（上一页/下一页，页码）
- URL更新页码（?page=2）
- 分页时保持过滤器/排序
- 页面为空时显示'未找到用户'

性能：
- 对于10k总用户，加载时间<500ms
- 没有n+1查询问题

用户体验：
- 获取期间显示加载状态
- 第一页禁用上一页，最后一页禁用下一页
- 显示当前页（例如，"第2页，共15页"）
- 键盘导航工作（箭头键）

测试：
- 分页逻辑的单元测试
- 完整流程的集成测试"
```

**为什么这很重要：**
- AI知道何时完成
- 您可以客观验证
- 减少来回迭代
- 设定清晰期望

---

## 通用原则

### 原则1：具体，不模糊

**规则**：提示中的每个词都应添加有用信息。

**转换示例：**

| 模糊 ❌         | 具体 ✅                                                               |
| -------------- | -------------------------------------------------------------------- |
| "让它更好"     | "通过添加数据库索引将响应时间从2s减少到<500ms"                       |
| "修复错误"     | "修复当用户不存在时UserService.findById中的空指针异常"               |
| "添加错误处理" | "将API调用包装在try-catch中，返回用户友好的消息，将错误记录到Sentry" |
| "提高安全性"   | "添加速率限制（10 req/min）、输入清理和JWT过期验证"                  |
| "使其响应式"   | "使用Tailwind断点：移动端堆叠（<768px），平板2列，桌面3列"           |

**实践：**

发送提示前，问自己：
- "这能更具体吗？" → 如果是，使其更具体
- "不熟悉我项目的人会理解吗？" → 如果不，添加上下文
- "我能量化这个要求吗？" → 如果是，添加数字/指标

---

### 原则2：展示，而不仅仅是告诉

**规则**：提供您想要的示例，而不仅仅是描述它。

**为什么示例重要：**
- 不同的人对词语的解释不同
- 示例消除歧义
- AI从示例中学习模式
- 减少误解

**模式：**

```
[描述] + [示例输入/输出] + [边缘情况]
```

**示例：**

**只是告诉（不清楚）：**
```
"以用户友好的方式格式化日期"
```

**展示（清楚）：**
```
"以用户友好的相对格式格式化日期：
- 今天：'今天下午2:30'
- 昨天：'昨天下午2:30'
- 本周：'周一下午2:30'
- 今年：'3月15日下午2:30'
- 更早：'2023年3月15日'

使用带AM/PM的12小时时间。正确处理时区（用户本地时间）。

边缘情况：
- 刚刚（<1分钟前）：'刚刚'
- 无效日期：'无效日期'
- 未来日期：使用绝对格式"
```

**真实场景：**

**之前（模糊）：**
```
"创建错误消息组件"
```

**之后（带示例）：**
```
"创建显示错误的ErrorMessage组件，如下所示：

示例1（字段错误）：
  [X] 需要电子邮件

示例2（API错误）：
  [!] 保存用户失败。请再试一次。

示例3（多个错误）：
  [!] 请修复以下：
      • 需要电子邮件
      • 密码必须至少8个字符

Props：
- error: string | string[]
- type: 'field' | 'api' | 'warning'
- dismissible?: boolean

样式：
- 'field'和'api'的红色边框和图标
- 'warning'的黄色
- 使用Tailwind颜色：red-500、yellow-500
- 图标来自Heroicons"
```

---

### 原则3：使用增量优化

**规则**：从宽泛开始，然后缩小。不要试图在第一次尝试时完善提示。

**迭代模式：**

```
迭代1：基本请求 → 获得工作代码
迭代2：添加约束 → 优化实现
迭代3：处理边缘情况 → 完善
```

**示例进展：**

**迭代1（使其工作）：**
```
"在src/api/users.ts中创建用户名搜索功能"
```

↓ *AI生成基本搜索*

**迭代2（添加要求）：**
```
"更新搜索以：
- 不区分大小写
- 搜索名字和姓氏
- 按相关性返回结果（精确匹配优先）"
```

↓ *AI优化实现*

**迭代3（边缘情况）：**
```
"处理这些边缘情况：
- 空搜索查询 → 返回所有用户
- 特殊字符 → 正确转义
- 非常长的查询（>100字符）→ 截断并警告"
```

**为什么这有效：**
- 每次迭代都建立在先前工作之上
- AI更好地保持上下文
- 您可以在每一步验证
- 比一个巨大的提示更不容易让人不知所措

**何时使用单次拍摄与迭代：**

| 场景                 | 方法             |
| -------------------- | ---------------- |
| 简单、明确定义的任务 | 单次全面提示     |
| 复杂功能             | 迭代优化         |
| 不确定要求           | 从简单开始，迭代 |
| 已知模式             | 单次详细提示     |
| 新领域               | 通过迭代探索     |

---

### 原则4：明确引用文件和模式

**规则**：告诉AI确切在哪里寻找上下文和要遵循的模式。

**模式结构：**

```
"[任务]遵循[参考文件]中的模式。
使用[特定函数/类]作为示例。
上下文在[docs文件]中。"
```

**示例：**

**糟糕（无引用）：**
```
"添加创建帖子的新API端点"
```

**良好（有引用）：**
```
"在src/api/posts.ts中添加新的POST /api/posts端点，遵循
src/api/users.ts中POST /api/users的相同模式。

具体：
- 使用相同的验证中间件方法
- 遵循相同的错误处理模式
- 使用相同的响应格式（201 Created带location头）

数据库架构在src/models/Post.ts中。
身份验证中间件在src/middleware/auth.ts中。"
```

**引用类型：**

```
├─ 代码模式："遵循[文件]中的模式"
├─ 架构文档："根据docs/architecture/api-design.md中的架构"
├─ 类似功能："像src/api/auth.ts中的用户注册流程"
├─ 样式指南："遵循.cursorrules中的约定"
└─ 决策记录："根据docs/decisions/001-api-design.md中的决定"
```

**好处：**
- AI理解您项目的风格
- 功能间代码一致
- 减少解释约定的需要
- 更快、更准确的实现

---

### 原则5：在提示中分离关注点

**规则**：不要在一个提示中混合多个不相关的任务。

**糟糕（混合关注点）：**
```
"添加用户身份验证，修复帖子页面上的损坏分页，
并更新标题样式以匹配新设计"
```

**为什么失败：**
- AI上下文分散在三个不同区域
- 更难验证每个部分
- 如果一个部分失败，难以调试
- 增加认知负荷

**良好（分离）：**

**提示1：**
```
"在src/api/auth.ts中使用JWT令牌实现用户身份验证"
```

**提示2（第一个完成后）：**
```
"修复src/components/PostList.tsx中的分页错误，其中
下一页按钮出现在最后一页"
```

**提示3（第二个完成后）：**
```
"更新src/components/Header.tsx中的标题样式以匹配
designs/header-v2.png中的设计"
```

**例外：**必须一起完成的相关任务可以组合：

```
"添加密码重置功能：
1. POST /api/auth/reset-request端点（生成令牌，发送邮件）
2. POST /api/auth/reset-confirm端点（验证令牌，更新密码）
3. 更新User模型以包含resetToken和resetTokenExpiry字段

这些必须一起实现才能使功能工作。"
```

**决策框架：**

```
问："这些任务可以由不同的开发人员独立完成吗？"
├─ 是 → 分离提示
└─ 否 → 组合提示可以
```

---

## 上下文加载策略

### 上下文层次结构

**理解AI的视角：**

```
┌─────────────────────────────────────────┐
│  AI如何看待您的上下文（优先级）   │
├─────────────────────────────────────────┤
│  1. 您当前的提示（最高）       │
│  2. 最近包含的文件             │
│  3. 之前的对话               │
│  4. 项目配置文件         │
│  5. 早期上下文（最低）            │
└─────────────────────────────────────────┘
```

**含义：**最近、最明确提到的上下文具有最高影响。

---

### 策略1：即时上下文加载

**原则：**仅包含当前任务所需的内容，根据需要加载更多。

**反模式：**
```
"以防万一，包含src/中的所有文件"
[AI上下文膨胀，性能下降]
```

**更好的模式：**
```
会话开始：仅包含任务描述+架构概述
步骤1：加载与当前任务直接相关的2-3个文件
步骤2：如果AI需要更多上下文，添加特定文件
步骤3：完成任务，从上下文中删除文件
```

**示例工作流程：**

**初始提示：**
```
"阅读docs/architecture/api-design.md。我需要添加一个新端点
用于用户配置文件更新。先不要实现，只需确认您
理解架构。"
```

↓ *AI确认理解*

**实现提示：**
```
"现在在src/api/users.ts中实现PUT /api/users/:id。包括：
- src/api/users.ts（现有端点用于模式）
- src/models/User.ts（架构）
- src/middleware/validation.ts（验证方法）"
```

**结果：**
- 最小上下文使用
- AI拥有确切所需
- 可以扩展到大型实现

---

### 策略2：文档优先方法

**原则：**将计划写入.md文件，在提示中引用它们。

**模式：**

```
┌──────────────────────────────────────────┐
│  1. 将计划写入docs/plans/feature.md │
│  2. 提示："在[文件]中实现计划"  │
│  3. AI读取计划（一次性上下文成本）│
│  4. AI实现（需要最少提示）│
└──────────────────────────────────────────┘
```

**好处：**
- 计划在会话间可重用
- 版本控制
- 人类可编辑
- 初始读取后零上下文成本

**示例：**

**而不是：**
```
"添加具有这些要求的用户身份验证：[3000字]"
[每次提到时都使用大量上下文]
```

**这样做：**
```
您："创建docs/plans/authentication.md，包含全面计划"
AI：[编写详细计划]
您：[审查并编辑计划]
您："实现docs/plans/authentication.md"
AI：[读取计划，实现]
```

**上下文节省：**
- 初始方法：每次提示3,000令牌 × 10次提示 = 30,000令牌
- 文档方法：一次3,000令牌 + 10 × 20令牌 = 3,200令牌
- **节省：令牌减少89%**

---

### 策略3：渐进式披露

**原则：**逐渐揭示复杂性，而不是一次性全部。

**模式：**

```
级别1：高级架构
级别2：组件细节
级别3：实现细节
级别4：边缘情况和优化
```

**示例：复杂功能实现**

**级别1（架构）：**
```
"我们正在构建实时聊天功能。架构：
- 前端：src/components/chat/中的React组件
- 后端：src/websocket/chat.ts中的WebSocket服务器
- 数据库：D1（Cloudflare）中的消息
- 状态：Zustand存储

阅读docs/architecture/realtime-chat.md了解完整详情。
您理解整体方法吗？"
```

↓ *AI确认*

**级别2（组件结构）：**
```
"让我们从前端结构开始。创建这些组件：
- ChatWindow（容器）
- MessageList（显示消息）
- MessageInput（用户输入）
- UserList（在线用户）

先不要实现，只需创建文件结构和组件
骨架与props/类型。"
```

↓ *AI创建结构*

**级别3（实现）：**
```
"现在实现MessageList组件。包括：
- 1000+消息的虚拟滚动
- 新消息时自动滚动到底部
- 滚动到顶部时加载更多

参考src/components/feed/PostList.tsx的虚拟滚动模式。"
```

↓ *AI实现*

**级别4（完善）：**
```
"向MessageList添加这些增强功能：
- 挂载时滚动到第一条未读消息
- 高亮提及（@username）
- 显示'用户正在输入'指示器
- 处理消息编辑/删除"
```

**为什么这有效：**
- AI不会被复杂性压倒
- 您在每个级别验证
- 容易纠正方向
- 自然的调试点

---

### 策略4：智能文件引用

**原则：**根据AI需要策略性地引用文件。

**引用类型：**

```
1. 模式引用："遵循[文件]中的模式"
   → AI学习风格，不需要完整文件内容

2. 架构引用："架构在[文件]中"
   → AI需要读取文件以了解结构

3. 集成引用："与[文件]集成"
   → AI需要理解接口

4. 上下文引用："相关逻辑在[文件]中"
   → AI应该意识到，可能需要读取
```

**示例：**

```
"实现用户配置文件更新端点。

模式：遵循src/api/users.ts中的POST /users模式（第45-78行）
架构：src/models/User.ts中的User模型
集成：使用来自src/middleware/validation.ts的ValidationMiddleware
上下文：src/api/auth.ts中的相关身份验证逻辑（供参考，除非相关否则无需读取）"
```

**文件引用语法：**

```
完整文件："阅读src/api/users.ts"
特定函数："参见src/api/users.ts中的handleUserUpdate"
行范围："src/api/users.ts第45-78行中的模式"
多个文件："阅读src/api/users.ts和src/models/User.ts"
```

---

### 策略5：上下文锚定

**原则：**建立跨对话持续存在的稳定参考点。

**锚定类型：**

```
└─ 架构文档（docs/architecture/）
└─ 项目约定（.cursorrules）
└─ 关键示例（实现良好的功能）
└─ 决策记录（docs/decisions/）
```

**模式：**

**会话开始：**
```
"本次会话，我们的锚点是：
1. API设计：docs/architecture/api-design.md
2. 代码风格：.cursorrules
3. 数据库模式：src/database/BaseRepository.ts

为所有实现引用这些。确认您已阅读它们。"
```

**会话期间：**
```
"根据我们的API设计锚点，实现GET /api/users/:id"
[AI记住锚点文档，遵循约定]
```

**好处：**
- 跨对话的一致引用
- 减少重复上下文的需要
- AI开发您项目的"心智模型"
- 更容易保持对话连贯性

---

## 常见反模式

### 反模式1：模糊希望

**描述：**希望AI会在没有明确指导的情况下"弄清楚"您想要什么。

**示例：**
```
"让应用程序更好"
```

**为什么失败：**
- "更好"是主观的
- 没有可衡量的结果
- AI随机猜测
- 浪费您的时间审查不相关的更改

**修复：**
```
"改进用户列表页面性能：
- 当前：1000用户3秒加载时间
- 目标：<500ms加载时间
- 方法：实现虚拟滚动和分页
- 测量：使用浏览器Performance API"
```

**教训：**如果您无法衡量，AI就无法优化。

---

### 反模式2：上下文转储

**描述：**包含所有内容"以防万一"而没有方向。

**示例：**
```
"这是我的整个代码库：[粘贴50个文件]
现在修复登录错误"
```

**为什么失败：**
- AI被不相关的上下文压倒
- 增加成本（令牌）
- 响应更慢
- AI可能专注于错误的区域

**修复：**
```
"登录错误：用户提交时得到500错误。

相关文件：
- src/api/auth.ts（登录端点，第45行抛出错误）
- src/middleware/validation.ts（验证登录请求）
- 错误日志：[粘贴特定错误消息]

期望：200 OK带JWT令牌
实际：500内部服务器错误"
```

**教训：**上下文质量 > 上下文数量

---

### 反模式3：假设陷阱

**描述：**假设AI在没有解释的情况下了解您的项目细节。

**示例：**
```
"添加我们讨论的功能"
```

**为什么失败：**
- AI没有先前的对话（如果是新会话）
- 即使在同一会话中，也可能不记得细节
- 引用模糊

**修复：**
```
"添加基于用户角色的访问控制功能：
- 三个角色：admin、editor、viewer（如docs/plans/rbac.md中记录）
- src/middleware/rbac.ts中的中间件
- 每个API请求上检查角色
- 遵循我们身份验证中间件的模式"
```

**教训：**明确。永远不要假设"AI知道"。

---

### 反模式4：移动目标

**描述：**在没有明确沟通的情况下在实现中途更改要求。

**示例：**
```
提示1："添加每页10项的分页"
[AI实现]
提示2："实际上改为20，并添加过滤器、排序和..."
[AI对保留什么与更改什么感到困惑"
```

**为什么失败：**
- 不清楚什么在变与什么保持不变
- AI可能不必要地重做一切
- 上下文变得混乱

**修复：**
```
提示2："保留您构建的分页结构，但更新：
- 将每页项从10更改为20
- 添加这些新功能：
  - 按状态过滤（下拉菜单）
  - 按日期/名称排序（切换）

不要更改：现有分页逻辑、URL参数或API结构"
```

**教训：**清楚区分更改、添加和删除。

---

### 反模式5：无验证

**描述：**不提供成功标准，所以AI没有"完成"的定义。

**示例：**
```
"实现用户搜索"
[AI实现某些东西]
您："这不是我想要的"
[重复5次]
```

**为什么失败：**
- AI猜测"完成"意味着什么
- 没有客观衡量
- 双方都沮丧

**修复：**
```
"实现用户搜索。成功意味着：

必须有：
- 标题中的搜索框
- 搜索名字、姓氏、电子邮件
- 结果出现在搜索框下方的下拉菜单中
- 点击结果 → 导航到用户配置文件
- 防抖搜索（500ms）

最好有（如果有时间）：
- 高亮匹配文本
- 在结果中显示用户头像
- 键盘导航（箭头键）

测试：
- 空搜索 → 无结果下拉菜单
- 'john' → 显示所有John
- 特殊字符 → 无错误"
```

**教训：**明确和客观地定义"完成"。

---

### 反模式6：工具不匹配

**描述：**对工具或模型使用错误的提示方法。

**示例：**
```
[对探索任务使用单次提示]
"探索代码库并弄清楚为什么它慢"
[AI给出通用建议而不是调查]
```

**为什么失败：**
- 有些任务需要多轮
- 单次提示无法涵盖开放式探索
- 上下文管理很重要

**修复：**

**迭代1：**
```
"分析用户列表页面性能。阅读src/pages/UserList.tsx
并报告您发现的内容。"
```

**迭代2（基于发现）：**
```
"您发现了N+1查询。阅读src/api/users.ts并提出使用
急切加载的修复方法。"
```

**迭代3：**
```
"使用必要的数据库查询更改实现您提出的修复方法。"
```

**教训：**将提示风格与任务类型匹配（探索 vs 实现 vs 调试）。

---

### 反模式7：忽略错误

**描述：**调试时不提供错误消息和日志。

**示例：**
```
"登录不工作，修复它"
```

**为什么失败：**
- AI必须猜测问题
- 在错误问题上浪费时间
- 可能不修复实际错误

**修复：**
```
"登录失败并出现此错误：

错误消息：
  TypeError: Cannot read property 'id' of undefined
  at src/api/auth.ts:45

堆栈跟踪：
  at handleLogin (src/api/auth.ts:45:10)
  at src/middleware/validation.ts:12:5

发生了什么：
- 用户提交登录表单
- 请求到达handleLogin
- 在第45行访问user.id时崩溃

上下文：
- 这在我们添加电子邮件验证后开始
- 只发生在未验证用户上
- 验证用户可以正常登录

相关代码：src/api/auth.ts第40-50行"
```

**教训：**调试需要数据。提供错误消息、堆栈跟踪和上下文。

---

### 反模式8：范围蔓延

**描述：**在没有清晰任务边界的情况下不断添加要求。

**示例：**
```
"添加联系表单"
[AI开始]
"哦还添加电子邮件验证"
[AI调整]
"并发送给多个收件人"
[AI调整]
"并记录提交到数据库"
[AI对要实现哪个版本感到困惑]
```

**为什么失败：**
- AI可能多次重做工作
- 不清楚什么在范围内
- 上下文变得混乱
- 实现可能不一致

**修复：**

**选项1：先计划**
```
"我需要一个联系表单。让我先思考要求：
- 表单字段：姓名、电子邮件、主题、消息
- 验证：电子邮件格式、必填字段
- 提交：发送电子邮件到admin@example.com
- 记录：保存到数据库
- 用户体验：显示成功消息，清除表单

创建docs/plans/contact-form.md，包含实现计划。"

[审查计划]

"实现docs/plans/contact-form.md"
```

**选项2：清晰阶段的迭代**
```
阶段1："创建带验证的基本表单"
[完成]
阶段2："使用现有EmailService添加电子邮件发送"
[完成]
阶段3："添加数据库记录"
```

**教训：**预先定义完整范围或使用清晰的迭代阶段。

---

### 反模式9：静默约束

**描述：**在脑中有要求但不沟通它们。

**示例：**
```
"添加用户注册"
[AI使用bcrypt实现]
您："我想要argon2，不是bcrypt！"
```

**为什么失败：**
- AI做出合理的假设
- 您对选择感到惊讶
- 浪费实现时间

**修复：**
```
"添加具有这些细节的用户注册：

密码哈希：使用argon2（不是bcrypt）- 安全要求
数据库：使用我们现有的UserRepository模式
验证：电子邮件格式+密码强度（8+字符，必须包含数字）
电子邮件：使用EmailService发送欢迎电子邮件（不要内联实现）
错误：返回400带字段特定错误（不是通用500）
测试：包括完整流程的集成测试"
```

**教训：**如果重要，明确说明。不要假设AI会猜测您的偏好。

---

### 反模式10：过度工程请求

**描述：**要求比需要更多的复杂性。

**示例：**
```
"为这个简单的博客应用程序构建可扩展的微服务架构，包括事件溯源、
CQRS、分布式跟踪和GraphQL"
```

**为什么失败：**
- 巨大范围
- 对要求过于复杂
- 实现永远
- 难以维护

**修复：**
```
"构建一个简单的博客应用程序：
- 单体架构（一个代码库）
- REST API（我们很了解）
- PostgreSQL（我们的标准）
- 使用JWT的身份验证

保持简单。如果需要，我们以后可以扩展。

要求：
- 帖子：创建、读取、更新、删除
- 评论：创建、读取、删除
- 用户：注册、登录、配置文件
- 管理员：管理所有内容"
```

**教训：**从简单开始。仅在需要时添加复杂性。YAGNI（您不会需要它）。

---

## 提示演变

### 如何通过实践优化提示

**学习循环：**

```
┌─────────────────────────────────────────┐
│  1. 编写提示                        │
│  2. 获得AI响应                     │
│  3. 评估质量                    │
│  4. 识别什么不清楚           │
│  5. 优化提示                       │
│  6. 记录模式                    │
└─────────────────────────────────────────┘
```

### 模式识别

**保留"提示日记"：**

```markdown
## 什么有效：
- 引用特定文件将准确性提高90%
- 包含示例将迭代从3次减少到1次
- 分解为步骤：AI更好地理解复杂任务

## 什么无效：
- 模糊的"让它更好"提示毫无结果
- 转储20个文件压倒上下文
- 混合调试+功能工作导致混淆

## 发现的模式：
- 模板："实现[X]遵循[Y]中的模式" → 95%成功率
- 对于调试：始终包含错误消息+文件:行 → 更快解决
- 对于新功能：先写规范，然后实现 → 更一致
```

### A/B测试您的提示

**尝试变体：**

**版本A（基线）：**
```
"向用户表添加排序"
```

**版本B（带细节）：**
```
"向src/components/UserTable.tsx中的用户表添加排序。
排序按：姓名、电子邮件、创建日期。默认：姓名升序。
视觉指示器：排序列旁边的箭头图标。"
```

**测量：**
- 到工作代码的迭代次数？
- 结果更接近您想要的吗？
- 令牌使用差异？
- 节省的时间？

**结果：**版本B将迭代从4次减少到1次，节省了10分钟。

**行动：**在您的模板库中记录版本B模式。

---

## 衡量提示质量

### 定量指标

```
┌──────────────────────────────────────────────┐
│  提示质量记分卡                    │
├──────────────────────────────────────────────┤
│  • 到工作代码的迭代：1-2（好）    │
│  • 令牌使用：基线 vs 实际           │
│  • 完成时间：目标 vs 实际      │
│  • 代码质量：第一次通过审查    │
│  • AI混淆信号：提出的问题     │
└──────────────────────────────────────────────┘
```

### 定性指标

**好提示指标：**
- ✅ AI立即开始实现
- ✅ 不需要澄清问题
- ✅ 第一次实现接近目标
- ✅ 代码匹配项目模式
- ✅ AI主动处理边缘情况

**坏提示指标：**
- ❌ AI问许多澄清问题
- ❌ 需要多次迭代
- ❌ AI做出错误假设
- ❌ 代码不匹配项目风格
- ❌ 忽略边缘情况

### 自我评估问题

每次提示后，问：

```
1. 其他人能准确理解我想要什么吗？
2. 我是否提供了所有必要的上下文？
3. 我是否清楚指定了约束？
4. 我是否定义了成功标准？
5. 这个提示在新会话中会工作吗？
```

如果任何答案是"不"，请在发送前优化提示。

---

## 最佳实践检查清单

### 发送提示前

- [ ] **特异性检查**：是否清楚我想要什么？
- [ ] **上下文检查**：AI是否有必要信息？
- [ ] **约束检查**：边界是否明确定义？
- [ ] **成功标准检查**：我们能验证何时完成吗？
- [ ] **文件引用检查**：是否提到了相关文件/模式？
- [ ] **范围检查**：这是一个专注的任务，还是应该拆分？
- [ ] **示例检查**：示例会进一步澄清吗？
- [ ] **边缘情况检查**：我是否提到了重要的边缘情况？

### 实现期间

- [ ] **进度检查**：第一次响应后AI是否在正确轨道上？
- [ ] **路线纠正**：如果偏离轨道，立即纠正
- [ ] **增量验证**：在继续之前测试每个部分
- [ ] **上下文监控**：上下文是否变得臃肿？

### 完成后

- [ ] **质量检查**：代码是否满足成功标准？
- [ ] **模式识别**：这个提示中什么有效？
- [ ] **文档**：是否应该保存这个模式？
- [ ] **迭代分析**：花了多少轮？为什么？

---

## 快速参考

### 提示模板（基本）

```
[任务]：您想要完成什么

[上下文]：
- 相关文件：[列表]
- 架构：[概述或文档链接]
- 要遵循的模式：[参考]

[约束]：
- [约束1]
- [约束2]

[成功标准]：
- [标准1]
- [标准2]
```

### 提示模板（调试）

```
[问题]：简要描述

[错误消息]：
[粘贴确切错误]

[上下文]：
- 文件：[路径:行]
- 我在做什么：[操作]
- 期望行为：[描述]
- 实际行为：[描述]
- 已尝试：[列表]

[相关代码]：
[如果短则粘贴相关部分，或引用文件]
```

### 提示模板（功能）

```
[功能]：名称和简要描述

[实现计划]：
1. [步骤1]
2. [步骤2]

[参考模式]：
- 遵循模式在：[文件]
- 类似功能：[描述]

[要求]：
- 必须有：[列表]
- 最好有：[列表]

[测试]：
- [ ] 场景1
- [ ] 场景2
```

---

## 下一步

一旦您掌握了这些基础：

1. **任务特定模式** → 学习调试、功能、重构等的专门提示
2. **高级技术** → 多步骤工作流程、提示链接、优化
3. **模板库** → 常见场景的即用提示

**练习练习：**

1. 采用您最近使用的模糊提示，使用4组件框架重写它
2. 为您最常见的任务类型创建提示模板
3. 记录在您项目中效果良好的3个模式
4. 设置提示日记以跟踪什么有效

---

**相关文档：**
- [任务特定模式](./task-specific-patterns-zh.md) → 专门提示策略
- [高级技术](./advanced-techniques-zh.md) → 专家级提示
- [模板库](./template-library-zh.md) → 即用提示
- [上下文管理](../context-management/README-zh.md) → 有效管理AI上下文
- [故障排除指南](../troubleshooting/README-zh.md) → 当提示不工作时

**返回：**[提示指南主页](./README-zh.md)