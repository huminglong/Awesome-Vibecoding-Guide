# 任务特定提示模式 🎨

**掌握不同开发场景的专门提示策略**

---

## 目录

1. [功能实施](#功能实施)
2. [调试和错误解决](#调试和错误解决)
3. [重构](#重构)
4. [代码审查](#代码审查)
5. [文档](#文档)
6. [测试](#测试)
7. [性能优化](#性能优化)
8. [安全加固](#安全加固)

---

## 功能实施

### 概述

**目标**：让AI构建与现有代码无缝集成的新功能。

**关键挑战：**
- 理解现有模式
- 保持一致性
- 处理集成点
- 预测边缘情况

**成功模式：**

```
清晰要求 + 架构上下文 + 模式参考 + 示例
= 第一次尝试的高质量实施
```

---

### 模式1：简单功能添加

**何时使用**：向现有模块添加独立功能

**模板：**

```
在[FILE_PATH]中实施[FEATURE_NAME]。

要求：
- [要求1]
- [要求2]
- [要求3]

遵循[REFERENCE_FILE]中[REFERENCE_FEATURE]使用的模式。

成功标准：
- [标准1]
- [标准2]
```

**真实示例1：添加电子邮件验证**

**糟糕的提示：**
```
"添加电子邮件验证"
```

**好的提示：**
```
"向src/components/RegisterForm.tsx中的用户注册表单添加电子邮件验证。

要求：
- 在模糊时验证（不是每次击键）
- 在输入字段下方显示错误消息
- 检查格式：标准电子邮件正则表达式
- 必填字段（空 = 错误）

遵循同一文件中密码验证使用的模式（第45-67行）。

成功标准：
- 无效电子邮件 → 红色边框 + 错误消息'Please enter a valid email'
- 有效电子邮件 → 绿色边框，无错误消息
- 模糊时为空字段 → 错误消息'Email is required'
- 如果电子邮件无效，提交禁用

使用我们现有的FormError组件，来自src/components/common/FormError.tsx。"
```

**为什么好的提示有效：**
- ✅ 特定文件和位置
- ✅ 清晰的验证规则
- ✅ 定义了UX行为
- ✅ 引用现有模式
- ✅ 使用现有组件
- ✅ 可测量的成功标准

**结果**：AI生成与现有代码风格匹配的验证，处理所有情况，与FormError组件集成。

---